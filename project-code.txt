Código extraído el 28-05-2025, 10:16:53 a. m.


// ==========================================
// File: src\app.controller.spec.ts
// ==========================================

import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});


// ==========================================
// File: src\app.controller.ts
// ==========================================

import { Controller, Get, Post, Body, HttpException, HttpStatus, Param } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) { }

  @Get()
  getHello(): string {
    // Respuesta simple de string
    return this.appService.getHello();
  }

  // @Get('usuarioss')
  // obtenerUsuarios() {
  //   // Respuesta con array de objetos
  //   return [
  //     { id: 1, nombre: 'Juan Pérez', email: 'juan@ejemplo.com' },
  //     { id: 2, nombre: 'María García', email: 'maria@ejemplo.com' },
  //   ];
  // }

  // @Get('usuario/:id')
  // obtenerUsuario(@Param('id') id: string) {
  //   // Respuesta con objeto único
  //   if (isNaN(Number(id))) {
  //     throw new HttpException('El ID debe ser un número', HttpStatus.BAD_REQUEST);
  //   }
  //   return {
  //     id: Number(id),
  //     nombre: 'Usuario de ejemplo',
  //     email: 'usuario@ejemplo.com',
  //     fechaCreacion: new Date().toISOString()
  //   };
  // }

  // @Post('usuario')
  // crearUsuario(@Body() datosUsuario: any) {
  //   // Respuesta de creación
  //   return {
  //     id: Math.floor(Math.random() * 1000),
  //     ...datosUsuario,
  //     fechaCreacion: new Date().toISOString()
  //   };
  // }

  // @Get('vacio')
  // respuestaVacia() {
  //   // Probamos cómo maneja respuestas null/undefined
  //   return null;
  // }
}

// ==========================================
// File: src\app.module.ts
// ==========================================

import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { databaseConfig } from './config/database.config';

// Importamos nuestros módulos
import { RolModule } from './rol/infraestructura/config/rol.module';
import { PermisoModule } from './permiso/infraestructura/config/permiso.module';
import { RolPermisoModule } from './rol-permiso/infraestructura/config/rol-permiso.module';
import { UsuarioModule } from './usuario/infraestructura/config/usuario.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: '.env',
    }),
    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: databaseConfig,
    }),

    // Módulos de negocio
    RolModule,
    PermisoModule,
    RolPermisoModule,
    UsuarioModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule { }

// ==========================================
// File: src\app.service.ts
// ==========================================

import { Injectable, Logger } from '@nestjs/common';

@Injectable()
export class AppService {
  private readonly logger = new Logger(AppService.name);

  getHello(): string {
    // Probamos diferentes niveles de log
    this.logger.verbose('Mensaje muy detallado para debugging profundo');
    this.logger.debug('Información de debug para desarrollo');
    this.logger.log('Información general del flujo de la aplicación');
    this.logger.warn('Advertencia: algo puede no estar bien');

    return 'Hello World!';
  }
}

// ==========================================
// File: src\common\filters\domain-exception.filter.ts
// ==========================================

import { ArgumentsHost, Catch, ExceptionFilter, HttpStatus } from '@nestjs/common';
import { Response } from 'express';
import {
    RolDomainException,
    RolNombreDuplicadoException,
    RolNoEncontradoException,
    RolInactivoException,
    RolConDependenciasException,
    RolDatosInvalidosException
} from '../../rol/dominio/excepciones/rol-domain.exception';
import {
    PermisoDomainException,
    PermisoNombreDuplicadoException,
    PermisoCodigoDuplicadoException,
    PermisoNoEncontradoException,
    PermisoInactivoException,
    PermisoConDependenciasException,
    PermisoDatosInvalidosException
} from '../../permiso/dominio/excepciones/permiso-domain.exception';
import {
    RolPermisoDomainException,
    PermisoYaAsignnadoException,
    AsignacionNoEncontradaException,
    RolNoValidoException,
    PermisoNoValidoException,
    RolPermisoDatosInvalidosException
} from '../../rol-permiso/dominio/excepciones/rol-permiso-domain.exception';
import {
    UsuarioDomainException,
    UsuarioUsernameDuplicadoException,
    UsuarioNoEncontradoException,
    UsuarioInactivoException,
    UsuarioBloqueadoException,
    UsuarioConDependenciasException,
    PersonaYaTieneUsuarioException,
    PersonaNoValidaException,
    RolNoValidoException as UsuarioRolNoValidoException,
    UsuarioDatosInvalidosException,
    CredencialesInvalidasException
} from '../../usuario/dominio/excepciones/usuario-domain.exception';

@Catch(RolDomainException, PermisoDomainException, RolPermisoDomainException, UsuarioDomainException) // Agregamos UsuarioDomainException
export class DomainExceptionFilter implements ExceptionFilter {
    catch(exception: RolDomainException | PermisoDomainException | RolPermisoDomainException | UsuarioDomainException, host: ArgumentsHost) {
        const ctx = host.switchToHttp();
        const response = ctx.getResponse<Response>();
        const request = ctx.getRequest();

        const statusCode = this.getHttpStatusFromDomainException(exception);
        const errorCode = this.getErrorCodeFromDomainException(exception);

        const errorResponse = {
            success: false,
            statusCode,
            timestamp: new Date().toISOString(),
            path: request.url,
            method: request.method,
            message: exception.message,
            errorCode,
        };

        response.status(statusCode).json(errorResponse);
    }

    private getHttpStatusFromDomainException(exception: RolDomainException | PermisoDomainException | RolPermisoDomainException | UsuarioDomainException): number {
        // Excepciones de ROL
        if (exception instanceof RolNombreDuplicadoException) {
            return HttpStatus.CONFLICT;
        }
        if (exception instanceof RolNoEncontradoException) {
            return HttpStatus.NOT_FOUND;
        }
        if (exception instanceof RolInactivoException) {
            return HttpStatus.FORBIDDEN;
        }
        if (exception instanceof RolConDependenciasException) {
            return HttpStatus.CONFLICT;
        }
        if (exception instanceof RolDatosInvalidosException) {
            return HttpStatus.BAD_REQUEST;
        }

        // Excepciones de PERMISO
        if (exception instanceof PermisoNombreDuplicadoException) {
            return HttpStatus.CONFLICT;
        }
        if (exception instanceof PermisoCodigoDuplicadoException) {
            return HttpStatus.CONFLICT;
        }
        if (exception instanceof PermisoNoEncontradoException) {
            return HttpStatus.NOT_FOUND;
        }
        if (exception instanceof PermisoInactivoException) {
            return HttpStatus.FORBIDDEN;
        }
        if (exception instanceof PermisoConDependenciasException) {
            return HttpStatus.CONFLICT;
        }
        if (exception instanceof PermisoDatosInvalidosException) {
            return HttpStatus.BAD_REQUEST;
        }

        // Excepciones de ROL-PERMISO
        if (exception instanceof PermisoYaAsignnadoException) {
            return HttpStatus.CONFLICT;
        }
        if (exception instanceof AsignacionNoEncontradaException) {
            return HttpStatus.NOT_FOUND;
        }
        if (exception instanceof RolNoValidoException) {
            return HttpStatus.NOT_FOUND;
        }
        if (exception instanceof PermisoNoValidoException) {
            return HttpStatus.NOT_FOUND;
        }
        if (exception instanceof RolPermisoDatosInvalidosException) {
            return HttpStatus.BAD_REQUEST;
        }

        // Excepciones de USUARIO
        if (exception instanceof UsuarioUsernameDuplicadoException) {
            return HttpStatus.CONFLICT;
        }
        if (exception instanceof UsuarioNoEncontradoException) {
            return HttpStatus.NOT_FOUND;
        }
        if (exception instanceof UsuarioInactivoException) {
            return HttpStatus.FORBIDDEN;
        }
        if (exception instanceof UsuarioBloqueadoException) {
            return HttpStatus.FORBIDDEN;
        }
        if (exception instanceof UsuarioConDependenciasException) {
            return HttpStatus.CONFLICT;
        }
        if (exception instanceof PersonaYaTieneUsuarioException) {
            return HttpStatus.CONFLICT;
        }
        if (exception instanceof PersonaNoValidaException) {
            return HttpStatus.NOT_FOUND;
        }
        if (exception instanceof UsuarioRolNoValidoException) {
            return HttpStatus.NOT_FOUND;
        }
        if (exception instanceof UsuarioDatosInvalidosException) {
            return HttpStatus.BAD_REQUEST;
        }
        if (exception instanceof CredencialesInvalidasException) {
            return HttpStatus.UNAUTHORIZED;
        }

        return HttpStatus.BAD_REQUEST;
    }

    private getErrorCodeFromDomainException(exception: RolDomainException | PermisoDomainException | RolPermisoDomainException | UsuarioDomainException): string {
        // Códigos de error para ROL
        if (exception instanceof RolNombreDuplicadoException) {
            return 'ROL_NOMBRE_DUPLICADO';
        }
        if (exception instanceof RolNoEncontradoException) {
            return 'ROL_NO_ENCONTRADO';
        }
        if (exception instanceof RolInactivoException) {
            return 'ROL_INACTIVO';
        }
        if (exception instanceof RolConDependenciasException) {
            return 'ROL_CON_DEPENDENCIAS';
        }
        if (exception instanceof RolDatosInvalidosException) {
            return 'ROL_DATOS_INVALIDOS';
        }

        // Códigos de error para PERMISO
        if (exception instanceof PermisoNombreDuplicadoException) {
            return 'PERMISO_NOMBRE_DUPLICADO';
        }
        if (exception instanceof PermisoCodigoDuplicadoException) {
            return 'PERMISO_CODIGO_DUPLICADO';
        }
        if (exception instanceof PermisoNoEncontradoException) {
            return 'PERMISO_NO_ENCONTRADO';
        }
        if (exception instanceof PermisoInactivoException) {
            return 'PERMISO_INACTIVO';
        }
        if (exception instanceof PermisoConDependenciasException) {
            return 'PERMISO_CON_DEPENDENCIAS';
        }
        if (exception instanceof PermisoDatosInvalidosException) {
            return 'PERMISO_DATOS_INVALIDOS';
        }

        // Códigos de error para ROL-PERMISO
        if (exception instanceof PermisoYaAsignnadoException) {
            return 'PERMISO_YA_ASIGNADO';
        }
        if (exception instanceof AsignacionNoEncontradaException) {
            return 'ASIGNACION_NO_ENCONTRADA';
        }
        if (exception instanceof RolNoValidoException) {
            return 'ROL_NO_VALIDO';
        }
        if (exception instanceof PermisoNoValidoException) {
            return 'PERMISO_NO_VALIDO';
        }
        if (exception instanceof RolPermisoDatosInvalidosException) {
            return 'ROL_PERMISO_DATOS_INVALIDOS';
        }

        // Códigos de error para USUARIO
        if (exception instanceof UsuarioUsernameDuplicadoException) {
            return 'USUARIO_USERNAME_DUPLICADO';
        }
        if (exception instanceof UsuarioNoEncontradoException) {
            return 'USUARIO_NO_ENCONTRADO';
        }
        if (exception instanceof UsuarioInactivoException) {
            return 'USUARIO_INACTIVO';
        }
        if (exception instanceof UsuarioBloqueadoException) {
            return 'USUARIO_BLOQUEADO';
        }
        if (exception instanceof UsuarioConDependenciasException) {
            return 'USUARIO_CON_DEPENDENCIAS';
        }
        if (exception instanceof PersonaYaTieneUsuarioException) {
            return 'PERSONA_YA_TIENE_USUARIO';
        }
        if (exception instanceof PersonaNoValidaException) {
            return 'PERSONA_NO_VALIDA';
        }
        if (exception instanceof UsuarioRolNoValidoException) {
            return 'USUARIO_ROL_NO_VALIDO';
        }
        if (exception instanceof UsuarioDatosInvalidosException) {
            return 'USUARIO_DATOS_INVALIDOS';
        }
        if (exception instanceof CredencialesInvalidasException) {
            return 'CREDENCIALES_INVALIDAS';
        }

        return 'DOMAIN_ERROR';
    }
}

// ==========================================
// File: src\common\filters\global-exception.filter.ts
// ==========================================

import {
    ExceptionFilter,
    Catch,
    ArgumentsHost,
    HttpException,
    HttpStatus,
    Logger,
} from '@nestjs/common';
import { Request, Response } from 'express';
import {
    RolDomainException,
    RolNombreDuplicadoException,
    RolNoEncontradoException,
    RolInactivoException,
    RolConDependenciasException,
    RolDatosInvalidosException
} from '../../rol/dominio/excepciones/rol-domain.exception';
import {
    PermisoDomainException,
    PermisoNombreDuplicadoException,
    PermisoCodigoDuplicadoException,
    PermisoNoEncontradoException,
    PermisoInactivoException,
    PermisoConDependenciasException,
    PermisoDatosInvalidosException
} from '../../permiso/dominio/excepciones/permiso-domain.exception';
import {
    RolPermisoDomainException,
    PermisoYaAsignnadoException,
    AsignacionNoEncontradaException,
    RolNoValidoException,
    PermisoNoValidoException,
    RolPermisoDatosInvalidosException
} from '../../rol-permiso/dominio/excepciones/rol-permiso-domain.exception';
import {
    UsuarioDomainException,
    UsuarioUsernameDuplicadoException,
    UsuarioNoEncontradoException,
    UsuarioInactivoException,
    UsuarioBloqueadoException,
    UsuarioConDependenciasException,
    PersonaYaTieneUsuarioException,
    PersonaNoValidaException,
    RolNoValidoException as UsuarioRolNoValidoException,
    UsuarioDatosInvalidosException,
    CredencialesInvalidasException
} from '../../usuario/dominio/excepciones/usuario-domain.exception';

@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
    private readonly logger = new Logger(GlobalExceptionFilter.name);

    catch(exception: unknown, host: ArgumentsHost): void {
        const ctx = host.switchToHttp();
        const response = ctx.getResponse<Response>();
        const request = ctx.getRequest<Request>();

        const { status, message, errorCode } = this.determineErrorResponse(exception);

        const errorResponse = {
            success: false,
            statusCode: status,
            timestamp: new Date().toISOString(),
            path: request.url,
            method: request.method,
            message,
            errorCode,
        };

        this.logError(exception, request, status);
        response.status(status).json(errorResponse);
    }

    private determineErrorResponse(exception: unknown): {
        status: number;
        message: string;
        errorCode: string;
    } {
        if (this.isDomainException(exception)) {
            return this.handleDomainException(exception as RolDomainException | PermisoDomainException | RolPermisoDomainException | UsuarioDomainException);
        }

        if (exception instanceof HttpException) {
            const status = exception.getStatus();
            const response = exception.getResponse();

            return {
                status,
                message: typeof response === 'string' ? response : (response as any).message || exception.message,
                errorCode: this.getErrorCodeFromHttpStatus(status),
            };
        }

        return {
            status: HttpStatus.INTERNAL_SERVER_ERROR,
            message: 'Error interno del servidor',
            errorCode: 'INTERNAL_SERVER_ERROR',
        };
    }

    private isDomainException(exception: unknown): boolean {
        return exception instanceof RolDomainException ||
            exception instanceof PermisoDomainException ||
            exception instanceof RolPermisoDomainException ||
            exception instanceof UsuarioDomainException ||
            (exception instanceof Error && exception.constructor.name.includes('DomainException'));
    }

    private handleDomainException(exception: RolDomainException | PermisoDomainException | RolPermisoDomainException | UsuarioDomainException): {
        status: number;
        message: string;
        errorCode: string;
    } {
        // Excepciones de ROL (mantener código existente)
        if (exception instanceof RolNombreDuplicadoException) {
            return { status: HttpStatus.CONFLICT, message: exception.message, errorCode: 'ROL_NOMBRE_DUPLICADO' };
        }
        if (exception instanceof RolNoEncontradoException) {
            return { status: HttpStatus.NOT_FOUND, message: exception.message, errorCode: 'ROL_NO_ENCONTRADO' };
        }
        if (exception instanceof RolInactivoException) {
            return { status: HttpStatus.FORBIDDEN, message: exception.message, errorCode: 'ROL_INACTIVO' };
        }
        if (exception instanceof RolConDependenciasException) {
            return { status: HttpStatus.CONFLICT, message: exception.message, errorCode: 'ROL_CON_DEPENDENCIAS' };
        }
        if (exception instanceof RolDatosInvalidosException) {
            return { status: HttpStatus.BAD_REQUEST, message: exception.message, errorCode: 'ROL_DATOS_INVALIDOS' };
        }

        // Excepciones de PERMISO (mantener código existente)
        if (exception instanceof PermisoNombreDuplicadoException) {
            return { status: HttpStatus.CONFLICT, message: exception.message, errorCode: 'PERMISO_NOMBRE_DUPLICADO' };
        }
        if (exception instanceof PermisoCodigoDuplicadoException) {
            return { status: HttpStatus.CONFLICT, message: exception.message, errorCode: 'PERMISO_CODIGO_DUPLICADO' };
        }
        if (exception instanceof PermisoNoEncontradoException) {
            return { status: HttpStatus.NOT_FOUND, message: exception.message, errorCode: 'PERMISO_NO_ENCONTRADO' };
        }
        if (exception instanceof PermisoInactivoException) {
            return { status: HttpStatus.FORBIDDEN, message: exception.message, errorCode: 'PERMISO_INACTIVO' };
        }
        if (exception instanceof PermisoConDependenciasException) {
            return { status: HttpStatus.CONFLICT, message: exception.message, errorCode: 'PERMISO_CON_DEPENDENCIAS' };
        }
        if (exception instanceof PermisoDatosInvalidosException) {
            return { status: HttpStatus.BAD_REQUEST, message: exception.message, errorCode: 'PERMISO_DATOS_INVALIDOS' };
        }

        // Excepciones de ROL-PERMISO (mantener código existente)
        if (exception instanceof PermisoYaAsignnadoException) {
            return { status: HttpStatus.CONFLICT, message: exception.message, errorCode: 'PERMISO_YA_ASIGNADO' };
        }
        if (exception instanceof AsignacionNoEncontradaException) {
            return { status: HttpStatus.NOT_FOUND, message: exception.message, errorCode: 'ASIGNACION_NO_ENCONTRADA' };
        }
        if (exception instanceof RolNoValidoException) {
            return { status: HttpStatus.NOT_FOUND, message: exception.message, errorCode: 'ROL_NO_VALIDO' };
        }
        if (exception instanceof PermisoNoValidoException) {
            return { status: HttpStatus.NOT_FOUND, message: exception.message, errorCode: 'PERMISO_NO_VALIDO' };
        }
        if (exception instanceof RolPermisoDatosInvalidosException) {
            return { status: HttpStatus.BAD_REQUEST, message: exception.message, errorCode: 'ROL_PERMISO_DATOS_INVALIDOS' };
        }

        // Excepciones de USUARIO (NUEVAS)
        if (exception instanceof UsuarioUsernameDuplicadoException) {
            return { status: HttpStatus.CONFLICT, message: exception.message, errorCode: 'USUARIO_USERNAME_DUPLICADO' };
        }
        if (exception instanceof UsuarioNoEncontradoException) {
            return { status: HttpStatus.NOT_FOUND, message: exception.message, errorCode: 'USUARIO_NO_ENCONTRADO' };
        }
        if (exception instanceof UsuarioInactivoException) {
            return { status: HttpStatus.FORBIDDEN, message: exception.message, errorCode: 'USUARIO_INACTIVO' };
        }
        if (exception instanceof UsuarioBloqueadoException) {
            return { status: HttpStatus.FORBIDDEN, message: exception.message, errorCode: 'USUARIO_BLOQUEADO' };
        }
        if (exception instanceof UsuarioConDependenciasException) {
            return { status: HttpStatus.CONFLICT, message: exception.message, errorCode: 'USUARIO_CON_DEPENDENCIAS' };
        }
        if (exception instanceof PersonaYaTieneUsuarioException) {
            return { status: HttpStatus.CONFLICT, message: exception.message, errorCode: 'PERSONA_YA_TIENE_USUARIO' };
        }
        if (exception instanceof PersonaNoValidaException) {
            return { status: HttpStatus.NOT_FOUND, message: exception.message, errorCode: 'PERSONA_NO_VALIDA' };
        }
        if (exception instanceof UsuarioRolNoValidoException) {
            return { status: HttpStatus.NOT_FOUND, message: exception.message, errorCode: 'USUARIO_ROL_NO_VALIDO' };
        }
        if (exception instanceof UsuarioDatosInvalidosException) {
            return { status: HttpStatus.BAD_REQUEST, message: exception.message, errorCode: 'USUARIO_DATOS_INVALIDOS' };
        }
        if (exception instanceof CredencialesInvalidasException) {
            return { status: HttpStatus.UNAUTHORIZED, message: exception.message, errorCode: 'CREDENCIALES_INVALIDAS' };
        }

        return {
            status: HttpStatus.BAD_REQUEST,
            message: exception.message,
            errorCode: 'DOMAIN_ERROR',
        };
    }

    private getErrorCodeFromHttpStatus(status: number): string {
        const statusToErrorCode: Record<number, string> = {
            400: 'BAD_REQUEST',
            401: 'UNAUTHORIZED',
            403: 'FORBIDDEN',
            404: 'NOT_FOUND',
            409: 'CONFLICT',
            422: 'VALIDATION_ERROR',
            429: 'TOO_MANY_REQUESTS',
            500: 'INTERNAL_SERVER_ERROR',
        };

        return statusToErrorCode[status] || 'UNKNOWN_ERROR';
    }

    private logError(exception: unknown, request: Request, status: number): void {
        const message = `${request.method} ${request.url}`;

        if (status >= 500) {
            this.logger.error(
                `${message} - ${status}`,
                exception instanceof Error ? exception.stack : exception,
            );
        } else if (status >= 400) {
            this.logger.warn(`${message} - ${status} - ${exception}`);
        }
    }
}

// ==========================================
// File: src\common\interceptors\response-transform.interceptor.ts
// ==========================================

import {
    Injectable,
    NestInterceptor,
    ExecutionContext,
    CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { Request } from 'express';

// Definimos la estructura estándar de nuestras respuestas exitosas
export interface StandardResponse<T> {
    success: boolean;
    statusCode: number;
    timestamp: string;
    path: string;
    method: string;
    data: T;
    message?: string;
}

@Injectable()
export class ResponseTransformInterceptor<T>
    implements NestInterceptor<T, StandardResponse<T>> {

    intercept(
        context: ExecutionContext,
        next: CallHandler,
    ): Observable<StandardResponse<T>> {
        // Obtenemos información del contexto de la petición
        const ctx = context.switchToHttp();
        const request = ctx.getRequest<Request>();
        const response = ctx.getResponse();

        // Ejecutamos el handler y transformamos la respuesta
        return next.handle().pipe(
            map((data) => {
                // Este es el corazón del interceptor: transformamos cualquier respuesta
                // a nuestro formato estándar
                return this.transformResponse(data, request, response.statusCode);
            }),
        );
    }

    private transformResponse<T>(
        data: T,
        request: Request,
        statusCode: number,
    ): StandardResponse<T> {
        // Construimos la respuesta estándar que siempre tendrá la misma estructura
        return {
            success: true, // Para respuestas exitosas, siempre es true
            statusCode,
            timestamp: new Date().toISOString(),
            path: request.url,
            method: request.method,
            data: this.processData(data), // Procesamos los datos según el tipo
            message: this.generateSuccessMessage(request.method), // Mensaje contextual
        };
    }

    private processData<T>(data: T): T {
        // Si los datos ya vienen en el formato que esperamos, los retornamos tal como están
        if (data === null || data === undefined) {
            return data;
        }

        // Si es un array, podríamos agregar metadatos como count en el futuro
        if (Array.isArray(data)) {
            return data;
        }

        // Para objetos simples, los retornamos sin modificaciones
        return data;
    }

    private generateSuccessMessage(method: string): string {
        // Generamos mensajes contextualmente útiles basados en el método HTTP
        const methodMessages: Record<string, string> = {
            GET: 'Datos obtenidos exitosamente',
            POST: 'Recurso creado exitosamente',
            PUT: 'Recurso actualizado exitosamente',
            PATCH: 'Recurso actualizado parcialmente',
            DELETE: 'Recurso eliminado exitosamente',
        };

        return methodMessages[method] || 'Operación completada exitosamente';
    }
}

// ==========================================
// File: src\config\database.config.ts
// ==========================================

import { TypeOrmModuleOptions } from '@nestjs/typeorm';
import { ConfigService } from '@nestjs/config';

export const databaseConfig = (configService: ConfigService): TypeOrmModuleOptions => {
    // Validamos que las variables de entorno existan
    const host = configService.get<string>('DB_HOST');
    const port = configService.get<string>('DB_PORT');
    const username = configService.get<string>('DB_USERNAME');
    const password = configService.get<string>('DB_PASSWORD');
    const database = configService.get<string>('DB_DATABASE');

    // Si alguna variable crítica no existe, lanzamos un error explicativo
    if (!host || !port || !username || !password || !database) {
        throw new Error('Variables de entorno de base de datos no configuradas correctamente');
    }

    return {
        type: 'postgres',
        host,
        port: parseInt(port, 10), // Ahora sabemos que port no es undefined
        username,
        password,
        database,
        autoLoadEntities: true, // Carga automáticamente las entidades registradas
        synchronize: false, // No modifica la estructura existente de la BD
        logging: process.env.NODE_ENV === 'development', // Solo log en desarrollo
    };
};

// ==========================================
// File: src\config\logger.config.ts
// ==========================================

import { LogLevel } from '@nestjs/common';

export class LoggerConfig {
    // Definimos los niveles de log según el entorno
    static getLogLevels(): LogLevel[] {
        const environment = process.env.NODE_ENV || 'development';

        switch (environment) {
            case 'production':
                // En producción solo queremos errores y warnings críticos
                return ['error', 'warn'];
            case 'test':
                // En testing solo errores para no contaminar los resultados
                return ['error'];
            case 'development':
            default:
                // En desarrollo queremos ver todo para debuggear
                return ['error', 'warn', 'log', 'debug', 'verbose'];
        }
    }

    // Configuramos el formato de timestamp personalizado
    static getTimestamp(): string {
        const now = new Date();
        return now.toISOString().replace('T', ' ').substring(0, 19);
    }
}

// ==========================================
// File: src\main.ts
// ==========================================

import { NestFactory } from '@nestjs/core';
import { ValidationPipe, Logger } from '@nestjs/common';
import { AppModule } from './app.module';
import { LoggerConfig } from './config/logger.config';
import { GlobalExceptionFilter } from './common/filters/global-exception.filter';
import { ResponseTransformInterceptor } from './common/interceptors/response-transform.interceptor';

async function bootstrap() {
  const app = await NestFactory.create(AppModule, {
    logger: LoggerConfig.getLogLevels(),
  });

  // Configurar cookie parser  <- AGREGAR ESTAS LÍNEAS

  app.useGlobalFilters(new GlobalExceptionFilter());

  app.useGlobalInterceptors(new ResponseTransformInterceptor());

  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      transform: true,
      forbidNonWhitelisted: true,
    }),
  );

  const port = process.env.PORT || 3000;
  await app.listen(port);

  const logger = new Logger('Bootstrap');
  logger.log(`🚀 Aplicación iniciada en puerto ${port}`);
  logger.log(`🌍 Entorno: ${process.env.NODE_ENV || 'development'}`);
  logger.log(`🗄️  Base de datos: ${process.env.DB_HOST}:${process.env.DB_PORT}`);
}
bootstrap();

// ==========================================
// File: src\permiso\aplicacion\casos-uso\actualizar-permiso.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { PermisoDominioService } from '../../dominio/servicios/permiso-dominio.service';
import { ActualizarPermisoDto } from '../dtos/actualizar-permiso.dto';
import { PermisoRespuestaDto } from '../dtos/permiso-respuesta.dto';

export class ActualizarPermisoCasoUso {
    private readonly logger = new Logger(ActualizarPermisoCasoUso.name);

    constructor(
        private readonly permisoDominioService: PermisoDominioService
    ) { }

    async ejecutar(
        id: number,
        datos: ActualizarPermisoDto,
        idUsuarioEjecutor: number
    ): Promise<PermisoRespuestaDto> {
        try {
            const camposAActualizar = Object.keys(datos).filter(key => datos[key] !== undefined);
            this.logger.log(
                `Iniciando actualización de permiso ID ${id} por usuario ${idUsuarioEjecutor}`,
                { camposAActualizar }
            );

            const permisoActualizado = await this.permisoDominioService.actualizarPermiso(id, {
                nombre: datos.nombre,
                codigo: datos.codigo,
                descripcion: datos.descripcion,
                idUsuarioModificacion: idUsuarioEjecutor
            });

            this.logger.log(
                `Permiso actualizado exitosamente: ID ${id}`,
                {
                    nombreAnterior: datos.nombre ? 'actualizado' : 'sin cambios',
                    codigoAnterior: datos.codigo ? 'actualizado' : 'sin cambios',
                    descripcionAnterior: datos.descripcion !== undefined ? 'actualizada' : 'sin cambios'
                }
            );

            return new PermisoRespuestaDto(permisoActualizado);

        } catch (error) {
            this.logger.error(
                `Error al actualizar permiso ID ${id}: ${error.message}`,
                {
                    datosEntrada: {
                        camposEnviados: Object.keys(datos),
                        idPermiso: id
                    },
                    idUsuarioEjecutor,
                    tipoError: error.constructor.name
                }
            );
            throw error;
        }
    }
}

// ==========================================
// File: src\permiso\aplicacion\casos-uso\crear-permiso.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { PermisoDominioService } from '../../dominio/servicios/permiso-dominio.service';
import { CrearPermisoDto } from '../dtos/crear-permiso.dto';
import { PermisoRespuestaDto } from '../dtos/permiso-respuesta.dto';

export class CrearPermisoCasoUso {
    private readonly logger = new Logger(CrearPermisoCasoUso.name);

    constructor(
        private readonly permisoDominioService: PermisoDominioService
    ) { }

    async ejecutar(datos: CrearPermisoDto, idUsuarioEjecutor: number): Promise<PermisoRespuestaDto> {
        try {
            this.logger.log(`Iniciando creación de permiso: código "${datos.codigo}", nombre "${datos.nombre}" por usuario ${idUsuarioEjecutor}`);

            const permisoCreado = await this.permisoDominioService.crearPermiso({
                nombre: datos.nombre,
                codigo: datos.codigo,
                descripcion: datos.descripcion,
                idUsuarioCreacion: idUsuarioEjecutor
            });

            this.logger.log(`Permiso creado exitosamente: ID ${permisoCreado.id}, código: "${permisoCreado.codigo}", nombre: "${permisoCreado.nombre}"`);

            return new PermisoRespuestaDto(permisoCreado);

        } catch (error) {
            this.logger.error(
                `Error al crear permiso: ${error.message}`,
                {
                    datosEntrada: {
                        codigo: datos.codigo,
                        nombre: datos.nombre,
                        tieneDescripcion: !!datos.descripcion
                    },
                    idUsuarioEjecutor,
                    tipoError: error.constructor.name,
                }
            );
            throw error;
        }
    }
}

// ==========================================
// File: src\permiso\aplicacion\casos-uso\eliminar-permiso.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { PermisoDominioService, ResultadoEliminacion } from '../../dominio/servicios/permiso-dominio.service';

export class PermisoEliminadoDto {
    id: number;
    nombre: string;
    codigo: string;
    eliminadoPor: number;
    fechaEliminacion: string;
    mensaje: string;

    constructor(resultado: ResultadoEliminacion) {
        this.id = resultado.id;
        this.nombre = resultado.nombre;
        this.codigo = resultado.codigo;
        this.eliminadoPor = resultado.eliminadoPor;
        this.fechaEliminacion = resultado.fechaEliminacion.toISOString();
        this.mensaje = `El permiso "${resultado.codigo}" (${resultado.nombre}) ha sido eliminado exitosamente`;
    }
}

export class EliminarPermisoCasoUso {
    private readonly logger = new Logger(EliminarPermisoCasoUso.name);

    constructor(
        private readonly permisoDominioService: PermisoDominioService
    ) { }

    async ejecutar(id: number, idUsuarioEjecutor: number): Promise<PermisoEliminadoDto> {
        try {
            this.logger.log(
                `Iniciando eliminación (soft delete) de permiso ID ${id}`,
                {
                    auditoria: {
                        idPermiso: id,
                        idUsuarioEjecutor,
                        timestamp: new Date().toISOString(),
                        operacion: 'ELIMINAR_PERMISO'
                    }
                }
            );

            const resultadoEliminacion = await this.permisoDominioService.eliminarPermiso(id, idUsuarioEjecutor);

            this.logger.log(
                `Permiso eliminado exitosamente: ID ${resultadoEliminacion.id}, código: "${resultadoEliminacion.codigo}", nombre: "${resultadoEliminacion.nombre}"`,
                {
                    resultado: {
                        idPermiso: resultadoEliminacion.id,
                        codigoPermiso: resultadoEliminacion.codigo,
                        nombrePermiso: resultadoEliminacion.nombre,
                        estadoFinal: 'ELIMINADO',
                        eliminadoPor: resultadoEliminacion.eliminadoPor,
                        tipoEliminacion: 'SOFT_DELETE',
                        fechaEliminacion: resultadoEliminacion.fechaEliminacion.toISOString()
                    }
                }
            );

            return new PermisoEliminadoDto(resultadoEliminacion);

        } catch (error) {
            this.logger.error(
                `Error crítico al eliminar permiso ID ${id}: ${error.message}`,
                {
                    contextoError: {
                        idPermiso: id,
                        idUsuarioEjecutor,
                        tipoError: error.constructor.name,
                        momentoFallo: new Date().toISOString(),
                        operacionFallida: 'ELIMINAR_PERMISO'
                    }
                }
            );
            throw error;
        }
    }
}

// ==========================================
// File: src\permiso\aplicacion\casos-uso\listar-permisos.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { PermisoRepositorio } from '../../dominio/puertos/repositorios/permiso-repositorio.interface';
import { PermisoRespuestaDto } from '../dtos/permiso-respuesta.dto';

export enum TipoFiltroEstado {
    ACTIVOS = 'activos',
    ELIMINADOS = 'eliminados',
    TODOS = 'todos'
}

export interface FiltrosListarPermisos {
    estado?: TipoFiltroEstado;
    nombre?: string;
    codigo?: string;
    limite?: number;
    offset?: number;
}

export interface ResultadoPaginado<T> {
    datos: T[];
    total: number;
    limite: number;
    offset: number;
    totalPaginas: number;
    paginaActual: number;
    filtrosAplicados: {
        estado: TipoFiltroEstado;
        nombre?: string;
        codigo?: string;
    };
}

export class ListarPermisosCasoUso {
    private readonly logger = new Logger(ListarPermisosCasoUso.name);

    constructor(
        private readonly permisoRepositorio: PermisoRepositorio
    ) { }

    async ejecutar(filtros: FiltrosListarPermisos = {}): Promise<ResultadoPaginado<PermisoRespuestaDto>> {
        try {
            const limite = filtros.limite || 10;
            const offset = filtros.offset || 0;
            const estado = filtros.estado || TipoFiltroEstado.ACTIVOS;

            this.logger.log('Listando permisos', {
                filtros: {
                    estado,
                    nombre: filtros.nombre || 'sin filtro',
                    codigo: filtros.codigo || 'sin filtro',
                    paginacion: { limite, offset }
                }
            });

            const filtrosRepositorio = this.convertirFiltrosParaRepositorio(filtros, estado);

            const [permisos, total] = await Promise.all([
                this.permisoRepositorio.buscarTodos(filtrosRepositorio),
                this.permisoRepositorio.contarRegistros(this.getFiltrosConteo(estado))
            ]);

            this.logger.log(
                `Consulta de permisos completada: ${permisos.length} permisos obtenidos de ${total} totales`,
                {
                    metricas: {
                        resultadosEncontrados: permisos.length,
                        totalDisponible: total,
                        filtroEstado: estado,
                        tiempoRespuesta: 'rápido'
                    }
                }
            );

            const permisosDto = permisos.map(permiso => new PermisoRespuestaDto(permiso));
            const totalPaginas = Math.ceil(total / limite);
            const paginaActual = Math.floor(offset / limite) + 1;

            return {
                datos: permisosDto,
                total,
                limite,
                offset,
                totalPaginas,
                paginaActual,
                filtrosAplicados: {
                    estado,
                    nombre: filtros.nombre,
                    codigo: filtros.codigo
                }
            };

        } catch (error) {
            this.logger.error(
                `Error al listar permisos: ${error.message}`,
                {
                    filtrosAplicados: filtros,
                    tipoError: error.constructor.name
                }
            );
            throw error;
        }
    }

    private convertirFiltrosParaRepositorio(filtros: FiltrosListarPermisos, estado: TipoFiltroEstado): any {
        const filtrosRepo: any = {
            limite: filtros.limite,
            offset: filtros.offset,
            nombre: filtros.nombre,
            codigo: filtros.codigo
        };

        switch (estado) {
            case TipoFiltroEstado.ACTIVOS:
                filtrosRepo.activo = true;
                break;
            case TipoFiltroEstado.ELIMINADOS:
                filtrosRepo.activo = false;
                break;
            case TipoFiltroEstado.TODOS:
                break;
        }

        return filtrosRepo;
    }

    private getFiltrosConteo(estado: TipoFiltroEstado): any {
        switch (estado) {
            case TipoFiltroEstado.ACTIVOS:
                return { activo: true };
            case TipoFiltroEstado.ELIMINADOS:
                return { activo: false };
            case TipoFiltroEstado.TODOS:
                return {};
        }
    }
}

// ==========================================
// File: src\permiso\aplicacion\casos-uso\obtener-permiso.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { PermisoRepositorio } from '../../dominio/puertos/repositorios/permiso-repositorio.interface';
import { PermisoRespuestaDto } from '../dtos/permiso-respuesta.dto';

export class ObtenerPermisoCasoUso {
    private readonly logger = new Logger(ObtenerPermisoCasoUso.name);

    constructor(
        private readonly permisoRepositorio: PermisoRepositorio
    ) { }

    async ejecutar(id: number): Promise<PermisoRespuestaDto> {
        try {
            this.logger.debug(`Buscando permiso con ID ${id}`);

            const permiso = await this.permisoRepositorio.buscarPorId(id);

            if (!permiso) {
                this.logger.warn(`Intento de acceso a permiso inexistente: ID ${id}`);
                throw new Error(`No se encontró un permiso con ID ${id}`);
            }

            this.logger.debug(`Permiso encontrado: ID ${permiso.id}, código: "${permiso.codigo}", nombre: "${permiso.nombre}", activo: ${permiso.activo}`);

            return new PermisoRespuestaDto(permiso);

        } catch (error) {
            if (error.message.includes('No se encontró')) {
                this.logger.warn(`Permiso no encontrado: ID ${id}`);
            } else {
                this.logger.error(`Error técnico al buscar permiso ID ${id}: ${error.message}`);
            }
            throw error;
        }
    }
}

// ==========================================
// File: src\permiso\aplicacion\casos-uso\restaurar-permiso.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { PermisoDominioService } from '../../dominio/servicios/permiso-dominio.service';
import { PermisoRespuestaDto } from '../dtos/permiso-respuesta.dto';

export class RestaurarPermisoCasoUso {
    private readonly logger = new Logger(RestaurarPermisoCasoUso.name);

    constructor(
        private readonly permisoDominioService: PermisoDominioService
    ) { }

    async ejecutar(id: number, idUsuarioEjecutor: number): Promise<PermisoRespuestaDto> {
        try {
            this.logger.log(
                `Iniciando restauración de permiso eliminado: ID ${id}`,
                {
                    operacionRestauracion: {
                        idPermiso: id,
                        idUsuarioEjecutor,
                        timestamp: new Date().toISOString(),
                        razonOperacion: 'RESTAURAR_PERMISO_ELIMINADO'
                    }
                }
            );

            this.logger.debug(
                `Validando condiciones para restauración del permiso ID ${id}`,
                {
                    validaciones: [
                        'existencia_permiso',
                        'estado_eliminado',
                        'conflicto_nombres',
                        'conflicto_codigos'
                    ]
                }
            );

            const permisoRestaurado = await this.permisoDominioService.restaurarPermiso(id, idUsuarioEjecutor);

            this.logger.log(
                `Permiso restaurado exitosamente: ID ${id}, código: "${permisoRestaurado.codigo}", nombre: "${permisoRestaurado.nombre}"`,
                {
                    resultadoRestauracion: {
                        idPermiso: permisoRestaurado.id,
                        codigoPermiso: permisoRestaurado.codigo,
                        nombrePermiso: permisoRestaurado.nombre,
                        restauradoPor: idUsuarioEjecutor,
                        estadoFinal: 'ACTIVO',
                        fechaRestauracion: new Date().toISOString()
                    }
                }
            );

            return new PermisoRespuestaDto(permisoRestaurado);

        } catch (error) {
            this.logger.error(
                `Error al restaurar permiso ID ${id}: ${error.message}`,
                {
                    contextoErrorRestauracion: {
                        idPermiso: id,
                        idUsuarioEjecutor,
                        tipoError: error.constructor.name,
                        posiblesCausas: [
                            'permiso_no_existe',
                            'permiso_ya_activo',
                            'conflicto_nombre',
                            'conflicto_codigo',
                            'error_validacion'
                        ],
                        momentoError: new Date().toISOString()
                    }
                }
            );
            throw error;
        }
    }
}

// ==========================================
// File: src\permiso\aplicacion\dtos\actualizar-permiso.dto.ts
// ==========================================

import { IsNotEmpty, IsString, IsOptional, Length, Matches } from 'class-validator';

export class ActualizarPermisoDto {
    @IsOptional()
    @IsNotEmpty({ message: 'El nombre del permiso no puede estar vacío' })
    @IsString({ message: 'El nombre debe ser una cadena de texto' })
    @Length(2, 50, { message: 'El nombre debe tener entre 2 y 50 caracteres' })
    @Matches(/^[a-zA-ZáéíóúÁÉÍÓÚñÑ\s\-_]+$/, {
        message: 'El nombre solo puede contener letras, espacios, guiones y guiones bajos'
    })
    nombre?: string;

    @IsOptional()
    @IsNotEmpty({ message: 'El código del permiso no puede estar vacío' })
    @IsString({ message: 'El código debe ser una cadena de texto' })
    @Length(2, 50, { message: 'El código debe tener entre 2 y 50 caracteres' })
    @Matches(/^[a-zA-Z0-9\-_.]+$/, {
        message: 'El código solo puede contener letras, números, guiones, puntos y guiones bajos'
    })
    codigo?: string;

    @IsOptional()
    @IsString({ message: 'La descripción debe ser una cadena de texto' })
    @Length(0, 200, { message: 'La descripción no puede exceder 200 caracteres' })
    descripcion?: string;
}

// ==========================================
// File: src\permiso\aplicacion\dtos\crear-permiso.dto.ts
// ==========================================

import { IsNotEmpty, IsString, IsOptional, Length, Matches } from 'class-validator';

export class CrearPermisoDto {
    @IsNotEmpty({ message: 'El nombre del permiso es requerido' })
    @IsString({ message: 'El nombre debe ser una cadena de texto' })
    @Length(2, 50, { message: 'El nombre debe tener entre 2 y 50 caracteres' })
    @Matches(/^[a-zA-ZáéíóúÁÉÍÓÚñÑ\s\-_]+$/, {
        message: 'El nombre solo puede contener letras, espacios, guiones y guiones bajos'
    })
    nombre: string;

    @IsNotEmpty({ message: 'El código del permiso es requerido' })
    @IsString({ message: 'El código debe ser una cadena de texto' })
    @Length(2, 50, { message: 'El código debe tener entre 2 y 50 caracteres' })
    @Matches(/^[a-zA-Z0-9\-_.]+$/, {
        message: 'El código solo puede contener letras, números, guiones, puntos y guiones bajos'
    })
    codigo: string;

    @IsOptional()
    @IsString({ message: 'La descripción debe ser una cadena de texto' })
    @Length(0, 200, { message: 'La descripción no puede exceder 200 caracteres' })
    descripcion?: string;
}

// ==========================================
// File: src\permiso\aplicacion\dtos\permiso-respuesta.dto.ts
// ==========================================

export class PermisoRespuestaDto {
    id: number;
    nombre: string;
    codigo: string;
    descripcion: string | null;
    fechaCreacion: string; // Usamos string para tener control total sobre el formato de fecha
    idUsuarioCreacion: number | null;
    fechaModificacion: string | null;
    idUsuarioModificacion: number | null;
    activo: boolean;

    constructor(permiso: any) {
        this.id = permiso.id;
        this.nombre = permiso.nombre;
        this.codigo = permiso.codigo;
        this.descripcion = permiso.descripcion;
        // Formateamos las fechas de manera consistente
        this.fechaCreacion = permiso.fechaCreacion.toISOString();
        this.idUsuarioCreacion = permiso.idUsuarioCreacion;
        this.fechaModificacion = permiso.fechaModificacion?.toISOString() || null;
        this.idUsuarioModificacion = permiso.idUsuarioModificacion;
        this.activo = permiso.activo;
    }
}

// ==========================================
// File: src\permiso\dominio\entidades\permiso.entity.ts
// ==========================================

export class Permiso {
    private _id: number | undefined;
    private _nombre: string;
    private _descripcion: string | null;
    private _codigo: string;
    private _fechaCreacion: Date;
    private _idUsuarioCreacion: number | null;
    private _fechaModificacion: Date | null;
    private _idUsuarioModificacion: number | null;
    private _activo: boolean;

    constructor(params: {
        id?: number;
        nombre: string;
        descripcion?: string | null;
        codigo: string;
        fechaCreacion?: Date;
        idUsuarioCreacion?: number | null;
        fechaModificacion?: Date | null;
        idUsuarioModificacion?: number | null;
        activo?: boolean;
    }) {
        this.validarNombre(params.nombre);
        this.validarCodigo(params.codigo);

        this._id = params.id;
        this._nombre = params.nombre.trim();
        this._descripcion = params.descripcion?.trim() || null;
        this._codigo = params.codigo.trim();
        this._fechaCreacion = params.fechaCreacion || new Date();
        this._idUsuarioCreacion = params.idUsuarioCreacion || null;
        this._fechaModificacion = params.fechaModificacion || null;
        this._idUsuarioModificacion = params.idUsuarioModificacion || null;
        this._activo = params.activo !== undefined ? params.activo : true;
    }

    // Getters
    get id(): number {
        if (this._id === undefined) {
            throw new Error('El permiso no ha sido persistido aún');
        }
        return this._id;
    }

    get nombre(): string { return this._nombre; }
    get descripcion(): string | null { return this._descripcion; }
    get codigo(): string { return this._codigo; }
    get fechaCreacion(): Date { return this._fechaCreacion; }
    get idUsuarioCreacion(): number | null { return this._idUsuarioCreacion; }
    get fechaModificacion(): Date | null { return this._fechaModificacion; }
    get idUsuarioModificacion(): number | null { return this._idUsuarioModificacion; }
    get activo(): boolean { return this._activo; }

    // Métodos de negocio
    actualizar(datos: {
        nombre?: string;
        descripcion?: string;
        codigo?: string;
        idUsuarioModificacion: number;
    }): void {
        let huboCambios = false;

        if (datos.nombre && datos.nombre !== this._nombre) {
            this.validarNombre(datos.nombre);
            this._nombre = datos.nombre.trim();
            huboCambios = true;
        }

        if (datos.codigo && datos.codigo !== this._codigo) {
            this.validarCodigo(datos.codigo);
            this._codigo = datos.codigo.trim();
            huboCambios = true;
        }

        if (datos.descripcion !== undefined && datos.descripcion !== this._descripcion) {
            this._descripcion = datos.descripcion?.trim() || null;
            huboCambios = true;
        }

        if (huboCambios) {
            this._fechaModificacion = new Date();
            this._idUsuarioModificacion = datos.idUsuarioModificacion;
        }
    }

    desactivar(idUsuarioModificacion: number): void {
        if (!this._activo) {
            throw new Error('El permiso ya está desactivado');
        }
        this._activo = false;
        this._fechaModificacion = new Date();
        this._idUsuarioModificacion = idUsuarioModificacion;
    }

    activar(idUsuarioModificacion: number): void {
        if (this._activo) {
            throw new Error('El permiso ya está activo');
        }
        this._activo = true;
        this._fechaModificacion = new Date();
        this._idUsuarioModificacion = idUsuarioModificacion;
    }

    private validarNombre(nombre: string): void {
        if (!nombre || nombre.trim().length === 0) {
            throw new Error('El nombre del permiso es requerido');
        }
        if (nombre.trim().length < 2) {
            throw new Error('El nombre del permiso debe tener al menos 2 caracteres');
        }
        if (nombre.trim().length > 50) {
            throw new Error('El nombre del permiso no puede exceder 50 caracteres');
        }
        const caracteresPermitidos = /^[a-zA-ZáéíóúÁÉÍÓÚñÑ\s\-_]+$/;
        if (!caracteresPermitidos.test(nombre.trim())) {
            throw new Error('El nombre del permiso contiene caracteres no permitidos');
        }
    }

    private validarCodigo(codigo: string): void {
        if (!codigo || codigo.trim().length === 0) {
            throw new Error('El código del permiso es requerido');
        }
        if (codigo.trim().length < 2) {
            throw new Error('El código del permiso debe tener al menos 2 caracteres');
        }
        if (codigo.trim().length > 50) {
            throw new Error('El código del permiso no puede exceder 50 caracteres');
        }
        const caracteresPermitidos = /^[a-zA-Z0-9\-_.]+$/;
        if (!caracteresPermitidos.test(codigo.trim())) {
            throw new Error('El código del permiso solo puede contener letras, números, guiones, puntos y guiones bajos');
        }
    }

    puedeSerModificado(): boolean {
        return this._activo;
    }

    toString(): string {
        return `Permiso[id=${this._id}, codigo=${this._codigo}, nombre=${this._nombre}, activo=${this._activo}]`;
    }
}

// ==========================================
// File: src\permiso\dominio\excepciones\permiso-domain.exception.ts
// ==========================================

// Clase base para todas las excepciones de dominio relacionadas con permisos
export abstract class PermisoDomainException extends Error {
    constructor(message: string) {
        super(message);
        this.name = this.constructor.name;
    }
}

// Excepción para cuando se intenta crear un permiso con un nombre que ya existe
export class PermisoNombreDuplicadoException extends PermisoDomainException {
    constructor(nombre: string) {
        super(`Ya existe un permiso con el nombre "${nombre}"`);
    }
}

// Excepción para cuando se intenta crear un permiso con un código que ya existe
export class PermisoCodigoDuplicadoException extends PermisoDomainException {
    constructor(codigo: string) {
        super(`Ya existe un permiso con el código "${codigo}"`);
    }
}

// Excepción para cuando se busca un permiso que no existe
export class PermisoNoEncontradoException extends PermisoDomainException {
    constructor(id: number) {
        super(`No se encontró un permiso con ID ${id}`);
    }
}

// Excepción para cuando se intenta operar sobre un permiso inactivo
export class PermisoInactivoException extends PermisoDomainException {
    constructor(id: number) {
        super(`El permiso con ID ${id} está inactivo y no puede ser modificado`);
    }
}

// Excepción para cuando se intenta eliminar un permiso que tiene dependencias
export class PermisoConDependenciasException extends PermisoDomainException {
    constructor(id: number, dependencias: string[]) {
        super(`No se puede eliminar el permiso con ID ${id} porque tiene dependencias en: ${dependencias.join(', ')}`);
    }
}

// Excepción para validaciones de datos de entrada
export class PermisoDatosInvalidosException extends PermisoDomainException {
    constructor(mensaje: string) {
        super(mensaje);
    }
}

// ==========================================
// File: src\permiso\dominio\puertos\repositorios\permiso-repositorio.interface.ts
// ==========================================

import { Permiso } from '../../entidades/permiso.entity';

// Esta interfaz define QUÉ necesita nuestro dominio, no CÓMO se implementa
export interface PermisoRepositorio {
    // Operaciones básicas CRUD
    guardar(permiso: Permiso): Promise<Permiso>;
    buscarPorId(id: number): Promise<Permiso | null>;
    buscarTodos(filtros?: {
        activo?: boolean;
        nombre?: string;
        codigo?: string;
        limite?: number;
        offset?: number;
    }): Promise<Permiso[]>;
    eliminar(id: number, idUsuarioEjecutor: number): Promise<void>;
    restaurar(id: number, idUsuarioEjecutor: number): Promise<void>;

    // Validaciones específicas
    existeConNombre(nombre: string, idExcluir?: number): Promise<boolean>;
    existeConCodigo(codigo: string, idExcluir?: number): Promise<boolean>;
    existeYEstaActivo(id: number): Promise<boolean>;
    puedeSerEliminado(id: number): Promise<{
        puedeEliminarse: boolean;
        razon?: string;
        dependencias?: string[];
    }>;
    contarRegistros(filtros?: { activo?: boolean }): Promise<number>;
}

// ==========================================
// File: src\permiso\dominio\servicios\permiso-dominio.service.ts
// ==========================================

import { Permiso } from '../entidades/permiso.entity';
import { PermisoRepositorio } from '../puertos/repositorios/permiso-repositorio.interface';
import {
    PermisoNombreDuplicadoException,
    PermisoCodigoDuplicadoException,
    PermisoNoEncontradoException,
    PermisoInactivoException,
    PermisoConDependenciasException,
    PermisoDatosInvalidosException
} from '../excepciones/permiso-domain.exception';

export interface ResultadoEliminacion {
    id: number;
    nombre: string;
    codigo: string;
    fechaEliminacion: Date;
    eliminadoPor: number;
}

export class PermisoDominioService {
    constructor(private readonly permisoRepositorio: PermisoRepositorio) { }

    async validarNombreUnico(nombre: string, idExcluir?: number): Promise<void> {
        const existeNombre = await this.permisoRepositorio.existeConNombre(nombre, idExcluir);
        if (existeNombre) {
            throw new PermisoNombreDuplicadoException(nombre);
        }
    }

    async validarCodigoUnico(codigo: string, idExcluir?: number): Promise<void> {
        const existeCodigo = await this.permisoRepositorio.existeConCodigo(codigo, idExcluir);
        if (existeCodigo) {
            throw new PermisoCodigoDuplicadoException(codigo);
        }
    }

    async validarExistenciaYEstadoActivo(id: number): Promise<Permiso> {
        const permiso = await this.permisoRepositorio.buscarPorId(id);
        if (!permiso) {
            throw new PermisoNoEncontradoException(id);
        }

        if (!permiso.activo) {
            throw new PermisoInactivoException(id);
        }

        return permiso;
    }

    async validarPuedeSerEliminado(id: number): Promise<void> {
        const resultadoValidacion = await this.permisoRepositorio.puedeSerEliminado(id);

        if (!resultadoValidacion.puedeEliminarse) {
            throw new PermisoConDependenciasException(id, resultadoValidacion.dependencias || []);
        }
    }

    async crearPermiso(datos: {
        nombre: string;
        descripcion?: string;
        codigo: string;
        idUsuarioCreacion: number;
    }): Promise<Permiso> {
        await this.validarNombreUnico(datos.nombre);
        await this.validarCodigoUnico(datos.codigo);

        const nuevoPermiso = new Permiso({
            nombre: datos.nombre,
            descripcion: datos.descripcion,
            codigo: datos.codigo,
            idUsuarioCreacion: datos.idUsuarioCreacion,
        });

        return await this.permisoRepositorio.guardar(nuevoPermiso);
    }

    async actualizarPermiso(id: number, datos: {
        nombre?: string;
        descripcion?: string;
        codigo?: string;
        idUsuarioModificacion: number;
    }): Promise<Permiso> {
        const permiso = await this.validarExistenciaYEstadoActivo(id);

        if (datos.nombre && datos.nombre !== permiso.nombre) {
            await this.validarNombreUnico(datos.nombre, id);
        }

        if (datos.codigo && datos.codigo !== permiso.codigo) {
            await this.validarCodigoUnico(datos.codigo, id);
        }

        permiso.actualizar(datos);
        return await this.permisoRepositorio.guardar(permiso);
    }

    async eliminarPermiso(id: number, idUsuarioEjecutor: number): Promise<ResultadoEliminacion> {
        // Primero obtenemos y validamos el permiso
        const permiso = await this.validarExistenciaYEstadoActivo(id);

        // Guardamos la información que necesitaremos para la respuesta
        const informacionPermiso = {
            id: permiso.id,
            nombre: permiso.nombre,
            codigo: permiso.codigo
        };

        // Validamos que puede ser eliminado
        await this.validarPuedeSerEliminado(id);

        // Ejecutamos la eliminación
        await this.permisoRepositorio.eliminar(id, idUsuarioEjecutor);

        // Devolvemos información estructurada sobre lo que se eliminó
        return {
            id: informacionPermiso.id,
            nombre: informacionPermiso.nombre,
            codigo: informacionPermiso.codigo,
            fechaEliminacion: new Date(),
            eliminadoPor: idUsuarioEjecutor
        };
    }

    // Nueva funcionalidad: restaurar permiso eliminado
    async restaurarPermiso(id: number, idUsuarioEjecutor: number): Promise<Permiso> {
        const permiso = await this.permisoRepositorio.buscarPorId(id);
        if (!permiso) {
            throw new PermisoNoEncontradoException(id);
        }

        if (permiso.activo) {
            throw new PermisoDatosInvalidosException(`El permiso con ID ${id} ya está activo`);
        }

        // Verificamos que no haya conflicto de nombres y códigos al restaurar
        await this.validarNombreUnico(permiso.nombre, id);
        await this.validarCodigoUnico(permiso.codigo, id);

        await this.permisoRepositorio.restaurar(id, idUsuarioEjecutor);

        // Retornamos el permiso actualizado
        const permisoRestaurado = await this.permisoRepositorio.buscarPorId(id);
        return permisoRestaurado!;
    }
}

// ==========================================
// File: src\permiso\infraestructura\adaptadores\entrada\controladores\permiso.controller.ts
// ==========================================

import {
    Controller,
    Get,
    Post,
    Put,
    Delete,
    Patch,
    Body,
    Param,
    Query,
    ParseIntPipe,
    HttpStatus,
    HttpCode,
} from '@nestjs/common';
import { CrearPermisoCasoUso } from '../../../../aplicacion/casos-uso/crear-permiso.caso-uso';
import { ActualizarPermisoCasoUso } from '../../../../aplicacion/casos-uso/actualizar-permiso.caso-uso';
import { ObtenerPermisoCasoUso } from '../../../../aplicacion/casos-uso/obtener-permiso.caso-uso';
import { ListarPermisosCasoUso, FiltrosListarPermisos, TipoFiltroEstado } from '../../../../aplicacion/casos-uso/listar-permisos.caso-uso';
import { EliminarPermisoCasoUso } from '../../../../aplicacion/casos-uso/eliminar-permiso.caso-uso';
import { RestaurarPermisoCasoUso } from '../../../../aplicacion/casos-uso/restaurar-permiso.caso-uso';
import { CrearPermisoDto } from '../../../../aplicacion/dtos/crear-permiso.dto';
import { ActualizarPermisoDto } from '../../../../aplicacion/dtos/actualizar-permiso.dto';

@Controller('permisos')
export class PermisoController {
    constructor(
        private readonly crearPermisoCasoUso: CrearPermisoCasoUso,
        private readonly actualizarPermisoCasoUso: ActualizarPermisoCasoUso,
        private readonly obtenerPermisoCasoUso: ObtenerPermisoCasoUso,
        private readonly listarPermisosCasoUso: ListarPermisosCasoUso,
        private readonly eliminarPermisoCasoUso: EliminarPermisoCasoUso,
        private readonly restaurarPermisoCasoUso: RestaurarPermisoCasoUso,
    ) { }

    @Post()
    @HttpCode(HttpStatus.CREATED)
    async crear(@Body() crearPermisoDto: CrearPermisoDto) {
        const idUsuarioEjecutor = 1;
        return await this.crearPermisoCasoUso.ejecutar(crearPermisoDto, idUsuarioEjecutor);
    }

    /**
     * GET /permisos
     * Lista permisos con filtros mejorados y paginación.
     * 
     * Ejemplos de uso:
     * - GET /permisos (solo permisos activos, comportamiento por defecto)
     * - GET /permisos?estado=activos (explícitamente solo activos)
     * - GET /permisos?estado=eliminados (solo permisos eliminados/inactivos)
     * - GET /permisos?estado=todos (todos los permisos sin importar estado)
     * - GET /permisos?estado=activos&nombre=usuario (buscar "usuario" en nombre solo en activos)
     * - GET /permisos?estado=activos&codigo=crear (buscar "crear" en código solo en activos)
     * - GET /permisos?limite=5&offset=10&estado=todos (paginación con todos los estados)
     */
    @Get()
    async listar(
        @Query('estado') estado?: string,
        @Query('nombre') nombre?: string,
        @Query('codigo') codigo?: string,
        @Query('limite') limite?: string,
        @Query('offset') offset?: string,
    ) {
        const filtros: FiltrosListarPermisos = {};

        // Validamos y convertimos el parámetro de estado
        if (estado) {
            const estadosValidos = Object.values(TipoFiltroEstado);
            if (estadosValidos.includes(estado as TipoFiltroEstado)) {
                filtros.estado = estado as TipoFiltroEstado;
            } else {
                throw new Error(`Estado '${estado}' no válido. Estados permitidos: ${estadosValidos.join(', ')}`);
            }
        }

        if (nombre) {
            filtros.nombre = nombre;
        }

        if (codigo) {
            filtros.codigo = codigo;
        }

        // Validamos y convertimos los parámetros numéricos con límites razonables
        if (limite) {
            const limiteNum = parseInt(limite, 10);
            if (!isNaN(limiteNum) && limiteNum > 0 && limiteNum <= 100) {
                filtros.limite = limiteNum;
            } else {
                throw new Error('El límite debe ser un número entre 1 y 100');
            }
        }

        if (offset) {
            const offsetNum = parseInt(offset, 10);
            if (!isNaN(offsetNum) && offsetNum >= 0) {
                filtros.offset = offsetNum;
            } else {
                throw new Error('El offset debe ser un número mayor o igual a 0');
            }
        }

        return await this.listarPermisosCasoUso.ejecutar(filtros);
    }

    @Get(':id')
    async obtenerPorId(@Param('id', ParseIntPipe) id: number) {
        return await this.obtenerPermisoCasoUso.ejecutar(id);
    }

    @Put(':id')
    async actualizar(
        @Param('id', ParseIntPipe) id: number,
        @Body() actualizarPermisoDto: ActualizarPermisoDto,
    ) {
        const idUsuarioEjecutor = 1;
        return await this.actualizarPermisoCasoUso.ejecutar(id, actualizarPermisoDto, idUsuarioEjecutor);
    }

    @Delete(':id')
    async eliminar(@Param('id', ParseIntPipe) id: number) {
        const idUsuarioEjecutor = 1;
        return await this.eliminarPermisoCasoUso.ejecutar(id, idUsuarioEjecutor);
    }

    /**
     * PATCH /permisos/:id/restaurar
     * Restaura un permiso eliminado (soft delete) volviéndolo al estado activo.
     * 
     * Ejemplo: PATCH /permisos/5/restaurar
     */
    @Patch(':id/restaurar')
    async restaurar(@Param('id', ParseIntPipe) id: number) {
        const idUsuarioEjecutor = 1;
        return await this.restaurarPermisoCasoUso.ejecutar(id, idUsuarioEjecutor);
    }
}

// ==========================================
// File: src\permiso\infraestructura\adaptadores\salida\repositorios\mappers\permiso.mapper.ts
// ==========================================

import { Permiso } from '../../../../../dominio/entidades/permiso.entity';
import { PermisoOrmEntity } from '../typeorm/entidades/permiso.orm-entity';

export class PermisoMapper {
    /**
     * Convierte una entidad ORM de TypeORM a una entidad de dominio pura.
     * Este proceso es como traducir de "lenguaje de base de datos" a "lenguaje de negocio".
     */
    static toDomain(ormEntity: PermisoOrmEntity): Permiso {
        return new Permiso({
            id: ormEntity.id,
            nombre: ormEntity.nombre,
            descripcion: ormEntity.descripcion,
            codigo: ormEntity.codigo,
            fechaCreacion: ormEntity.fechaCreacion,
            idUsuarioCreacion: ormEntity.idUsuarioCreacion,
            fechaModificacion: ormEntity.fechaModificacion,
            idUsuarioModificacion: ormEntity.idUsuarioModificacion,
            activo: ormEntity.activo,
        });
    }

    /**
     * Convierte una entidad de dominio a una entidad ORM de TypeORM.
     * Este proceso prepara nuestros datos de negocio para ser persistidos.
     */
    static toOrm(domainEntity: Permiso): PermisoOrmEntity {
        const ormEntity = new PermisoOrmEntity();

        // Solo asignamos el ID si la entidad ya fue persistida
        try {
            ormEntity.id = domainEntity.id;
        } catch (error) {
            // Si la entidad no tiene ID, TypeORM hará un INSERT
        }

        ormEntity.nombre = domainEntity.nombre;
        ormEntity.descripcion = domainEntity.descripcion;
        ormEntity.codigo = domainEntity.codigo;
        ormEntity.fechaCreacion = domainEntity.fechaCreacion;
        ormEntity.idUsuarioCreacion = domainEntity.idUsuarioCreacion;
        ormEntity.fechaModificacion = domainEntity.fechaModificacion;
        ormEntity.idUsuarioModificacion = domainEntity.idUsuarioModificacion;
        ormEntity.activo = domainEntity.activo;

        return ormEntity;
    }

    /**
     * Convierte un array de entidades ORM a un array de entidades de dominio.
     * Útil para operaciones de listado que devuelven múltiples registros.
     */
    static toDomainArray(ormEntities: PermisoOrmEntity[]): Permiso[] {
        return ormEntities.map(ormEntity => this.toDomain(ormEntity));
    }
}

// ==========================================
// File: src\permiso\infraestructura\adaptadores\salida\repositorios\typeorm\entidades\permiso.orm-entity.ts
// ==========================================

import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';

@Entity('permiso')
export class PermisoOrmEntity {
    @PrimaryGeneratedColumn({ name: 'id' })
    id: number;

    @Column({ name: 'nombre', type: 'varchar', length: 50, nullable: false })
    nombre: string;

    @Column({ name: 'descripcion', type: 'varchar', length: 200, nullable: true })
    descripcion: string | null;

    @Column({ name: 'codigo', type: 'varchar', length: 50, nullable: false })
    codigo: string;

    @CreateDateColumn({ name: 'fecha_creacion', type: 'timestamp' })
    fechaCreacion: Date;

    @Column({ name: 'id_usuario_creacion', type: 'int', nullable: true })
    idUsuarioCreacion: number | null;

    @UpdateDateColumn({ name: 'fecha_modificacion', type: 'timestamp', nullable: true })
    fechaModificacion: Date | null;

    @Column({ name: 'id_usuario_modificacion', type: 'int', nullable: true })
    idUsuarioModificacion: number | null;

    @Column({ name: 'activo', type: 'boolean', default: true })
    activo: boolean;
}

// ==========================================
// File: src\permiso\infraestructura\adaptadores\salida\repositorios\typeorm\permiso.repository.ts
// ==========================================

import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Like, Not } from 'typeorm';
import { PermisoRepositorio } from '../../../../../dominio/puertos/repositorios/permiso-repositorio.interface';
import { Permiso } from '../../../../../dominio/entidades/permiso.entity';
import { PermisoOrmEntity } from './entidades/permiso.orm-entity';
import { PermisoMapper } from '../mappers/permiso.mapper';

@Injectable()
export class TypeOrmPermisoRepository implements PermisoRepositorio {
    constructor(
        @InjectRepository(PermisoOrmEntity)
        private readonly permisoRepository: Repository<PermisoOrmEntity>,
    ) { }

    async guardar(permiso: Permiso): Promise<Permiso> {
        try {
            // Convertimos la entidad de dominio a entidad ORM
            const permisoOrm = PermisoMapper.toOrm(permiso);

            // TypeORM determina automáticamente si debe hacer INSERT o UPDATE
            const permisoGuardado = await this.permisoRepository.save(permisoOrm);

            // Convertimos el resultado de vuelta a entidad de dominio
            return PermisoMapper.toDomain(permisoGuardado);
        } catch (error) {
            // Transformamos errores de base de datos a errores de dominio más comprensibles
            if (error.code === '23505') { // Código de PostgreSQL para violación de restricción única
                if (error.constraint?.includes('nombre')) {
                    throw new Error(`Ya existe un permiso con el nombre especificado`);
                }
                if (error.constraint?.includes('codigo')) {
                    throw new Error(`Ya existe un permiso con el código especificado`);
                }
                throw new Error(`Ya existe un permiso con los datos especificados`);
            }
            throw new Error(`Error al guardar el permiso: ${error.message}`);
        }
    }

    async buscarPorId(id: number): Promise<Permiso | null> {
        const permisoOrm = await this.permisoRepository.findOne({
            where: { id }
        });

        return permisoOrm ? PermisoMapper.toDomain(permisoOrm) : null;
    }

    async buscarTodos(filtros: {
        activo?: boolean;
        nombre?: string;
        codigo?: string;
        limite?: number;
        offset?: number;
    } = {}): Promise<Permiso[]> {
        // Construimos dinámicamente las condiciones de búsqueda
        const whereConditions: any = {};

        if (filtros.activo !== undefined) {
            whereConditions.activo = filtros.activo;
        }

        if (filtros.nombre) {
            // Búsqueda parcial insensible a mayúsculas/minúsculas
            whereConditions.nombre = Like(`%${filtros.nombre}%`);
        }

        if (filtros.codigo) {
            // Búsqueda parcial insensible a mayúsculas/minúsculas
            whereConditions.codigo = Like(`%${filtros.codigo}%`);
        }

        const permisosOrm = await this.permisoRepository.find({
            where: whereConditions,
            take: filtros.limite || 10,
            skip: filtros.offset || 0,
            order: {
                codigo: 'ASC', // Ordenamos por código alfabéticamente por defecto
            },
        });

        return PermisoMapper.toDomainArray(permisosOrm);
    }

    async eliminar(id: number, idUsuarioEjecutor: number): Promise<void> {
        // Implementamos soft delete actualizando el campo 'activo'
        const resultado = await this.permisoRepository.update(id, {
            activo: false,
            fechaModificacion: new Date(),
            idUsuarioModificacion: idUsuarioEjecutor,
        });

        if (resultado.affected === 0) {
            throw new Error(`No se pudo eliminar el permiso con ID ${id}. Puede que no exista.`);
        }
    }

    async restaurar(id: number, idUsuarioEjecutor: number): Promise<void> {
        // Implementamos la restauración de un permiso eliminado
        const resultado = await this.permisoRepository.update(id, {
            activo: true,
            fechaModificacion: new Date(),
            idUsuarioModificacion: idUsuarioEjecutor,
        });

        if (resultado.affected === 0) {
            throw new Error(`No se pudo restaurar el permiso con ID ${id}. Puede que no exista.`);
        }
    }

    async existeConNombre(nombre: string, idExcluir?: number): Promise<boolean> {
        const whereConditions: any = {
            nombre: nombre.trim(),
            activo: true, // Solo consideramos permisos activos para validación de unicidad
        };

        // Si estamos actualizando un permiso, excluimos su propio ID de la búsqueda
        if (idExcluir) {
            whereConditions.id = Not(idExcluir);
        }

        const count = await this.permisoRepository.count({
            where: whereConditions
        });

        return count > 0;
    }

    async existeConCodigo(codigo: string, idExcluir?: number): Promise<boolean> {
        const whereConditions: any = {
            codigo: codigo.trim(),
            activo: true, // Solo consideramos permisos activos para validación de unicidad
        };

        // Si estamos actualizando un permiso, excluimos su propio ID de la búsqueda
        if (idExcluir) {
            whereConditions.id = Not(idExcluir);
        }

        const count = await this.permisoRepository.count({
            where: whereConditions
        });

        return count > 0;
    }

    async existeYEstaActivo(id: number): Promise<boolean> {
        const count = await this.permisoRepository.count({
            where: {
                id,
                activo: true
            }
        });

        return count > 0;
    }

    async puedeSerEliminado(id: number): Promise<{
        puedeEliminarse: boolean;
        razon?: string;
        dependencias?: string[];
    }> {
        const dependencias: string[] = [];

        // Validación específica: roles activos que tienen este permiso asignado
        // La lógica aquí es que si eliminamos un permiso que está siendo usado
        // por roles activos, esos roles perderían funcionalidad inmediatamente
        const rolesActivosConEstePermiso = await this.permisoRepository.manager
            .createQueryBuilder()
            .select('COUNT(*)', 'count')
            .from('rol_permiso', 'rp')
            .innerJoin('rol', 'r', 'r.id = rp.id_rol')  // Join con tabla rol
            .where('rp.id_permiso = :idPermiso', { idPermiso: id })
            .andWhere('rp.activo = true')    // Asignación activa
            .andWhere('r.activo = true')     // Rol activo (esto es lo crítico)
            .getRawOne();

        const cantidadRoles = parseInt(rolesActivosConEstePermiso.count) || 0;

        if (cantidadRoles > 0) {
            // Explicamos el impacto operacional específico
            dependencias.push(`${cantidadRoles} rol(es) activo(s) perderían esta funcionalidad inmediatamente`);
        }

        if (dependencias.length > 0) {
            return {
                puedeEliminarse: false,
                razon: `No se puede desactivar el permiso porque roles activos lo están utilizando`,
                dependencias
            };
        }

        return { puedeEliminarse: true };
    }

    async contarRegistros(filtros: { activo?: boolean } = {}): Promise<number> {
        const whereConditions: any = {};

        if (filtros.activo !== undefined) {
            whereConditions.activo = filtros.activo;
        }

        return await this.permisoRepository.count({
            where: whereConditions
        });
    }
}

// ==========================================
// File: src\permiso\infraestructura\config\permiso.module.ts
// ==========================================

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';

// Importamos las entidades ORM para que TypeORM las reconozca
import { PermisoOrmEntity } from '../adaptadores/salida/repositorios/typeorm/entidades/permiso.orm-entity';

// Importamos el controlador que expondrá los endpoints
import { PermisoController } from '../adaptadores/entrada/controladores/permiso.controller';

// Importamos la implementación del repositorio
import { TypeOrmPermisoRepository } from '../adaptadores/salida/repositorios/typeorm/permiso.repository';

// Importamos el servicio de dominio
import { PermisoDominioService } from '../../dominio/servicios/permiso-dominio.service';

// Importamos todos los casos de uso
import { CrearPermisoCasoUso } from '../../aplicacion/casos-uso/crear-permiso.caso-uso';
import { ActualizarPermisoCasoUso } from '../../aplicacion/casos-uso/actualizar-permiso.caso-uso';
import { ObtenerPermisoCasoUso } from '../../aplicacion/casos-uso/obtener-permiso.caso-uso';
import { ListarPermisosCasoUso } from '../../aplicacion/casos-uso/listar-permisos.caso-uso';
import { EliminarPermisoCasoUso } from '../../aplicacion/casos-uso/eliminar-permiso.caso-uso';
import { RestaurarPermisoCasoUso } from '../../aplicacion/casos-uso/restaurar-permiso.caso-uso';

@Module({
    // Registramos las entidades ORM para que TypeORM pueda trabajar con ellas
    imports: [
        TypeOrmModule.forFeature([PermisoOrmEntity])
    ],

    // Declaramos qué controladores expondrá este módulo
    controllers: [
        PermisoController
    ],

    // Aquí es donde ocurre la magia de la inyección de dependencias
    providers: [
        // Registramos la implementación concreta del repositorio
        {
            provide: 'PermisoRepositorio',
            useClass: TypeOrmPermisoRepository,
        },

        // Registramos el servicio de dominio con su dependencia del repositorio
        {
            provide: PermisoDominioService,
            useFactory: (permisoRepositorio) => {
                return new PermisoDominioService(permisoRepositorio);
            },
            inject: ['PermisoRepositorio'],
        },

        // Registramos todos los casos de uso con sus respectivas dependencias
        {
            provide: CrearPermisoCasoUso,
            useFactory: (permisoDominioService) => {
                return new CrearPermisoCasoUso(permisoDominioService);
            },
            inject: [PermisoDominioService],
        },

        {
            provide: ActualizarPermisoCasoUso,
            useFactory: (permisoDominioService) => {
                return new ActualizarPermisoCasoUso(permisoDominioService);
            },
            inject: [PermisoDominioService],
        },

        {
            provide: ObtenerPermisoCasoUso,
            useFactory: (permisoRepositorio) => {
                return new ObtenerPermisoCasoUso(permisoRepositorio);
            },
            inject: ['PermisoRepositorio'],
        },

        {
            provide: ListarPermisosCasoUso,
            useFactory: (permisoRepositorio) => {
                return new ListarPermisosCasoUso(permisoRepositorio);
            },
            inject: ['PermisoRepositorio'],
        },

        {
            provide: EliminarPermisoCasoUso,
            useFactory: (permisoDominioService) => {
                return new EliminarPermisoCasoUso(permisoDominioService);
            },
            inject: [PermisoDominioService],
        },

        {
            provide: RestaurarPermisoCasoUso,
            useFactory: (permisoDominioService) => {
                return new RestaurarPermisoCasoUso(permisoDominioService);
            },
            inject: [PermisoDominioService],
        },
    ],

    // Exportamos servicios que otros módulos podrían necesitar
    exports: [
        'PermisoRepositorio',
        PermisoDominioService,
    ],
})
export class PermisoModule { }

// ==========================================
// File: src\rol\aplicacion\casos-uso\actualizar-rol.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { RolDominioService } from '../../dominio/servicios/rol-dominio.service';
import { ActualizarRolDto } from '../dtos/actualizar-rol.dto';
import { RolRespuestaDto } from '../dtos/rol-respuesta.dto';

export class ActualizarRolCasoUso {
    private readonly logger = new Logger(ActualizarRolCasoUso.name);

    constructor(
        private readonly rolDominioService: RolDominioService
    ) { }

    async ejecutar(
        id: number,
        datos: ActualizarRolDto,
        idUsuarioEjecutor: number
    ): Promise<RolRespuestaDto> {
        try {
            // Log con información específica sobre qué campos se están actualizando
            const camposAActualizar = Object.keys(datos).filter(key => datos[key] !== undefined);
            this.logger.log(
                `Iniciando actualización de rol ID ${id} por usuario ${idUsuarioEjecutor}`,
                { camposAActualizar } // Contexto estructurado adicional
            );

            const rolActualizado = await this.rolDominioService.actualizarRol(id, {
                nombre: datos.nombre,
                descripcion: datos.descripcion,
                idUsuarioModificacion: idUsuarioEjecutor
            });

            this.logger.log(
                `Rol actualizado exitosamente: ID ${id}`,
                {
                    nombreAnterior: datos.nombre ? 'actualizado' : 'sin cambios',
                    descripcionAnterior: datos.descripcion !== undefined ? 'actualizada' : 'sin cambios'
                }
            );

            return new RolRespuestaDto(rolActualizado);

        } catch (error) {
            this.logger.error(
                `Error al actualizar rol ID ${id}: ${error.message}`,
                {
                    datosEntrada: {
                        camposEnviados: Object.keys(datos),
                        idRol: id
                    },
                    idUsuarioEjecutor,
                    tipoError: error.constructor.name
                }
            );
            throw error;
        }
    }
}

// ==========================================
// File: src\rol\aplicacion\casos-uso\crear-rol.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { RolDominioService } from '../../dominio/servicios/rol-dominio.service';
import { CrearRolDto } from '../dtos/crear-rol.dto';
import { RolRespuestaDto } from '../dtos/rol-respuesta.dto';

export class CrearRolCasoUso {
    // Creamos una instancia de logger específica para este caso de uso
    // El nombre de la clase se usa como contexto, lo que nos ayuda a identificar de dónde vienen los logs
    private readonly logger = new Logger(CrearRolCasoUso.name);

    constructor(
        private readonly rolDominioService: RolDominioService
    ) { }

    async ejecutar(datos: CrearRolDto, idUsuarioEjecutor: number): Promise<RolRespuestaDto> {
        try {
            // Log de inicio con nivel 'log' (información general)
            // Incluimos contexto relevante pero sin datos sensibles
            this.logger.log(`Iniciando creación de rol: "${datos.nombre}" por usuario ${idUsuarioEjecutor}`);

            const rolCreado = await this.rolDominioService.crearRol({
                nombre: datos.nombre,
                descripcion: datos.descripcion,
                idUsuarioCreacion: idUsuarioEjecutor
            });

            // Log de éxito con información que ayuda a la trazabilidad
            this.logger.log(`Rol creado exitosamente: ID ${rolCreado.id}, nombre: "${rolCreado.nombre}"`);

            return new RolRespuestaDto(rolCreado);

        } catch (error) {
            // Log de error con contexto completo para debugging
            // Usamos 'error' como nivel para que sea fácil filtrar problemas
            this.logger.error(
                `Error al crear rol: ${error.message}`, // Mensaje principal del error
                {
                    // Contexto estructurado que ayuda en el debugging
                    datosEntrada: {
                        nombre: datos.nombre,
                        tieneDescripcion: !!datos.descripcion
                    }, // No logeamos la descripción completa por privacidad
                    idUsuarioEjecutor,
                    tipoError: error.constructor.name, // Nos ayuda a identificar el tipo de error
                }
            );

            // Re-lanzamos el error para que sea manejado por nuestro filtro global
            throw error;
        }
    }
}

// ==========================================
// File: src\rol\aplicacion\casos-uso\eliminar-rol.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { RolDominioService, ResultadoEliminacion } from '../../dominio/servicios/rol-dominio.service';

export class RolEliminadoDto {
    id: number;
    nombre: string;
    eliminadoPor: number;
    fechaEliminacion: string;
    mensaje: string;

    constructor(resultado: ResultadoEliminacion) {
        this.id = resultado.id;
        this.nombre = resultado.nombre;
        this.eliminadoPor = resultado.eliminadoPor;
        this.fechaEliminacion = resultado.fechaEliminacion.toISOString();
        this.mensaje = `El rol "${resultado.nombre}" ha sido eliminado exitosamente`;
    }
}

export class EliminarRolCasoUso {
    private readonly logger = new Logger(EliminarRolCasoUso.name);

    constructor(
        private readonly rolDominioService: RolDominioService
    ) { }

    async ejecutar(id: number, idUsuarioEjecutor: number): Promise<RolEliminadoDto> {
        try {
            this.logger.log(
                `Iniciando eliminación (soft delete) de rol ID ${id}`,
                {
                    auditoria: {
                        idRol: id,
                        idUsuarioEjecutor,
                        timestamp: new Date().toISOString(),
                        operacion: 'ELIMINAR_ROL'
                    }
                }
            );

            // El servicio de dominio ahora nos devuelve información sobre lo eliminado
            const resultadoEliminacion = await this.rolDominioService.eliminarRol(id, idUsuarioEjecutor);

            this.logger.log(
                `Rol eliminado exitosamente: ID ${resultadoEliminacion.id}, nombre: "${resultadoEliminacion.nombre}"`,
                {
                    resultado: {
                        idRol: resultadoEliminacion.id,
                        nombreRol: resultadoEliminacion.nombre,
                        estadoFinal: 'ELIMINADO',
                        eliminadoPor: resultadoEliminacion.eliminadoPor,
                        tipoEliminacion: 'SOFT_DELETE',
                        fechaEliminacion: resultadoEliminacion.fechaEliminacion.toISOString()
                    }
                }
            );

            return new RolEliminadoDto(resultadoEliminacion);

        } catch (error) {
            this.logger.error(
                `Error crítico al eliminar rol ID ${id}: ${error.message}`,
                {
                    contextoError: {
                        idRol: id,
                        idUsuarioEjecutor,
                        tipoError: error.constructor.name,
                        momentoFallo: new Date().toISOString(),
                        operacionFallida: 'ELIMINAR_ROL'
                    }
                }
            );
            throw error;
        }
    }
}

// ==========================================
// File: src\rol\aplicacion\casos-uso\listar-roles.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { RolRepositorio } from '../../dominio/puertos/repositorios/rol-repositorio.interface';
import { RolRespuestaDto } from '../dtos/rol-respuesta.dto';

export enum TipoFiltroEstado {
    ACTIVOS = 'activos',
    ELIMINADOS = 'eliminados',
    TODOS = 'todos'
}

export interface FiltrosListarRoles {
    estado?: TipoFiltroEstado;
    nombre?: string;
    limite?: number;
    offset?: number;
}

export interface ResultadoPaginado<T> {
    datos: T[];
    total: number;
    limite: number;
    offset: number;
    totalPaginas: number;
    paginaActual: number;
    filtrosAplicados: {
        estado: TipoFiltroEstado;
        nombre?: string;
    };
}

export class ListarRolesCasoUso {
    private readonly logger = new Logger(ListarRolesCasoUso.name);

    constructor(
        private readonly rolRepositorio: RolRepositorio
    ) { }

    async ejecutar(filtros: FiltrosListarRoles = {}): Promise<ResultadoPaginado<RolRespuestaDto>> {
        try {
            const limite = filtros.limite || 10;
            const offset = filtros.offset || 0;
            const estado = filtros.estado || TipoFiltroEstado.ACTIVOS;

            // Log con información estructurada sobre los filtros aplicados
            this.logger.log('Listando roles', {
                filtros: {
                    estado,
                    nombre: filtros.nombre || 'sin filtro',
                    paginacion: { limite, offset }
                }
            });

            const filtrosRepositorio = this.convertirFiltrosParaRepositorio(filtros, estado);

            const [roles, total] = await Promise.all([
                this.rolRepositorio.buscarTodos(filtrosRepositorio),
                this.rolRepositorio.contarRegistros(this.getFiltrosConteo(estado))
            ]);

            // Log con métricas útiles sobre los resultados
            this.logger.log(
                `Consulta de roles completada: ${roles.length} roles obtenidos de ${total} totales`,
                {
                    metricas: {
                        resultadosEncontrados: roles.length,
                        totalDisponible: total,
                        filtroEstado: estado,
                        tiempoRespuesta: 'rápido' // En una implementación real, podríamos medir tiempo real
                    }
                }
            );

            const rolesDto = roles.map(rol => new RolRespuestaDto(rol));
            const totalPaginas = Math.ceil(total / limite);
            const paginaActual = Math.floor(offset / limite) + 1;

            return {
                datos: rolesDto,
                total,
                limite,
                offset,
                totalPaginas,
                paginaActual,
                filtrosAplicados: {
                    estado,
                    nombre: filtros.nombre
                }
            };

        } catch (error) {
            this.logger.error(
                `Error al listar roles: ${error.message}`,
                {
                    filtrosAplicados: filtros,
                    tipoError: error.constructor.name
                }
            );
            throw error;
        }
    }

    private convertirFiltrosParaRepositorio(filtros: FiltrosListarRoles, estado: TipoFiltroEstado): any {
        const filtrosRepo: any = {
            limite: filtros.limite,
            offset: filtros.offset,
            nombre: filtros.nombre
        };

        switch (estado) {
            case TipoFiltroEstado.ACTIVOS:
                filtrosRepo.activo = true;
                break;
            case TipoFiltroEstado.ELIMINADOS:
                filtrosRepo.activo = false;
                break;
            case TipoFiltroEstado.TODOS:
                break;
        }

        return filtrosRepo;
    }

    private getFiltrosConteo(estado: TipoFiltroEstado): any {
        switch (estado) {
            case TipoFiltroEstado.ACTIVOS:
                return { activo: true };
            case TipoFiltroEstado.ELIMINADOS:
                return { activo: false };
            case TipoFiltroEstado.TODOS:
                return {};
        }
    }
}

// ==========================================
// File: src\rol\aplicacion\casos-uso\obtener-rol.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { RolRepositorio } from '../../dominio/puertos/repositorios/rol-repositorio.interface';
import { RolRespuestaDto } from '../dtos/rol-respuesta.dto';

export class ObtenerRolCasoUso {
    private readonly logger = new Logger(ObtenerRolCasoUso.name);

    constructor(
        private readonly rolRepositorio: RolRepositorio
    ) { }

    async ejecutar(id: number): Promise<RolRespuestaDto> {
        try {
            // Para operaciones de lectura simples, usamos 'debug' en lugar de 'log'
            // Esto nos permite tener información detallada en desarrollo pero reducir ruido en producción
            this.logger.debug(`Buscando rol con ID ${id}`);

            const rol = await this.rolRepositorio.buscarPorId(id);

            if (!rol) {
                // Este es un caso esperado de negocio, no un error técnico
                this.logger.warn(`Intento de acceso a rol inexistente: ID ${id}`);
                throw new Error(`No se encontró un rol con ID ${id}`);
            }

            this.logger.debug(`Rol encontrado: ID ${rol.id}, nombre: "${rol.nombre}", activo: ${rol.activo}`);

            return new RolRespuestaDto(rol);

        } catch (error) {
            // Solo logeamos como error si es algo inesperado
            if (error.message.includes('No se encontró')) {
                // Para errores esperados de negocio, usamos 'warn'
                this.logger.warn(`Rol no encontrado: ID ${id}`);
            } else {
                // Para errores técnicos inesperados, usamos 'error'
                this.logger.error(`Error técnico al buscar rol ID ${id}: ${error.message}`);
            }
            throw error;
        }
    }
}

// ==========================================
// File: src\rol\aplicacion\casos-uso\restaurar-rol.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { RolDominioService } from '../../dominio/servicios/rol-dominio.service';
import { RolRespuestaDto } from '../dtos/rol-respuesta.dto';

export class RestaurarRolCasoUso {
    private readonly logger = new Logger(RestaurarRolCasoUso.name);

    constructor(
        private readonly rolDominioService: RolDominioService
    ) { }

    async ejecutar(id: number, idUsuarioEjecutor: number): Promise<RolRespuestaDto> {
        try {
            // La restauración es una operación especial que merece logging detallado
            // Nos ayuda a entender patrones: ¿se eliminan roles por error frecuentemente?
            // ¿Hay usuarios específicos que restauran más que otros?
            this.logger.log(
                `Iniciando restauración de rol eliminado: ID ${id}`,
                {
                    operacionRestauracion: {
                        idRol: id,
                        idUsuarioEjecutor,
                        timestamp: new Date().toISOString(),
                        razonOperacion: 'RESTAURAR_ROL_ELIMINADO'
                    }
                }
            );

            // Registramos que estamos validando las condiciones para la restauración
            this.logger.debug(
                `Validando condiciones para restauración del rol ID ${id}`,
                {
                    validaciones: [
                        'existencia_rol',
                        'estado_eliminado',
                        'conflicto_nombres'
                    ]
                }
            );

            const rolRestaurado = await this.rolDominioService.restaurarRol(id, idUsuarioEjecutor);

            // Log de éxito con información completa del resultado
            this.logger.log(
                `Rol restaurado exitosamente: ID ${id}, nombre: "${rolRestaurado.nombre}"`,
                {
                    resultadoRestauracion: {
                        idRol: rolRestaurado.id,
                        nombreRol: rolRestaurado.nombre,
                        restauradoPor: idUsuarioEjecutor,
                        estadoFinal: 'ACTIVO',
                        fechaRestauracion: new Date().toISOString()
                    }
                }
            );

            return new RolRespuestaDto(rolRestaurado);

        } catch (error) {
            // Los errores en restauración pueden indicar problemas de datos o conflictos
            // Es importante capturar esta información para análisis posterior
            this.logger.error(
                `Error al restaurar rol ID ${id}: ${error.message}`,
                {
                    contextoErrorRestauracion: {
                        idRol: id,
                        idUsuarioEjecutor,
                        tipoError: error.constructor.name,
                        posiblesCausas: [
                            'rol_no_existe',
                            'rol_ya_activo',
                            'conflicto_nombre',
                            'error_validacion'
                        ],
                        momentoError: new Date().toISOString()
                    }
                }
            );
            throw error;
        }
    }
}

// ==========================================
// File: src\rol\aplicacion\dtos\actualizar-rol.dto.ts
// ==========================================

import { IsNotEmpty, IsString, IsOptional, Length, Matches } from 'class-validator';

export class ActualizarRolDto {
    @IsOptional()
    @IsNotEmpty({ message: 'El nombre del rol no puede estar vacío' })
    @IsString({ message: 'El nombre debe ser una cadena de texto' })
    @Length(2, 50, { message: 'El nombre debe tener entre 2 y 50 caracteres' })
    @Matches(/^[a-zA-ZáéíóúÁÉÍÓÚñÑ\s\-_]+$/, {
        message: 'El nombre solo puede contener letras, espacios, guiones y guiones bajos'
    })
    nombre?: string;

    @IsOptional()
    @IsString({ message: 'La descripción debe ser una cadena de texto' })
    @Length(0, 200, { message: 'La descripción no puede exceder 200 caracteres' })
    descripcion?: string;
}

// ==========================================
// File: src\rol\aplicacion\dtos\crear-rol.dto.ts
// ==========================================

import { IsNotEmpty, IsString, IsOptional, Length, Matches } from 'class-validator';

export class CrearRolDto {
    @IsNotEmpty({ message: 'El nombre del rol es requerido' })
    @IsString({ message: 'El nombre debe ser una cadena de texto' })
    @Length(2, 50, { message: 'El nombre debe tener entre 2 y 50 caracteres' })
    @Matches(/^[a-zA-ZáéíóúÁÉÍÓÚñÑ\s\-_]+$/, {
        message: 'El nombre solo puede contener letras, espacios, guiones y guiones bajos'
    })
    nombre: string;

    @IsOptional()
    @IsString({ message: 'La descripción debe ser una cadena de texto' })
    @Length(0, 200, { message: 'La descripción no puede exceder 200 caracteres' })
    descripcion?: string;
}

// ==========================================
// File: src\rol\aplicacion\dtos\rol-respuesta.dto.ts
// ==========================================

export class RolRespuestaDto {
    id: number;
    nombre: string;
    descripcion: string | null;
    fechaCreacion: string; // Usamos string para tener control total sobre el formato de fecha
    idUsuarioCreacion: number | null;
    fechaModificacion: string | null;
    idUsuarioModificacion: number | null;
    activo: boolean;

    constructor(rol: any) {
        this.id = rol.id;
        this.nombre = rol.nombre;
        this.descripcion = rol.descripcion;
        // Formateamos las fechas de manera consistente
        this.fechaCreacion = rol.fechaCreacion.toISOString();
        this.idUsuarioCreacion = rol.idUsuarioCreacion;
        this.fechaModificacion = rol.fechaModificacion?.toISOString() || null;
        this.idUsuarioModificacion = rol.idUsuarioModificacion;
        this.activo = rol.activo;
    }
}

// ==========================================
// File: src\rol\dominio\entidades\rol.entity.ts
// ==========================================

export class Rol {
    private _id: number | undefined;
    private _nombre: string;
    private _descripcion: string | null;
    private _fechaCreacion: Date;
    private _idUsuarioCreacion: number | null;
    private _fechaModificacion: Date | null;
    private _idUsuarioModificacion: number | null;
    private _activo: boolean;

    constructor(params: {
        id?: number;
        nombre: string;
        descripcion?: string | null;
        fechaCreacion?: Date;
        idUsuarioCreacion?: number | null;
        fechaModificacion?: Date | null;
        idUsuarioModificacion?: number | null;
        activo?: boolean;
    }) {
        this.validarNombre(params.nombre);

        this._id = params.id;
        this._nombre = params.nombre.trim();
        this._descripcion = params.descripcion?.trim() || null;
        this._fechaCreacion = params.fechaCreacion || new Date();
        this._idUsuarioCreacion = params.idUsuarioCreacion || null;
        this._fechaModificacion = params.fechaModificacion || null;
        this._idUsuarioModificacion = params.idUsuarioModificacion || null;
        this._activo = params.activo !== undefined ? params.activo : true;
    }

    // Getters (sin cambios)
    get id(): number {
        if (this._id === undefined) {
            throw new Error('El rol no ha sido persistido aún');
        }
        return this._id;
    }

    get nombre(): string { return this._nombre; }
    get descripcion(): string | null { return this._descripcion; }
    get fechaCreacion(): Date { return this._fechaCreacion; }
    get idUsuarioCreacion(): number | null { return this._idUsuarioCreacion; }
    get fechaModificacion(): Date | null { return this._fechaModificacion; }
    get idUsuarioModificacion(): number | null { return this._idUsuarioModificacion; }
    get activo(): boolean { return this._activo; }

    // Métodos de negocio corregidos
    actualizar(datos: {
        nombre?: string;
        descripcion?: string;
        idUsuarioModificacion: number;
    }): void {
        let huboCambios = false; // Variable con nombre consistente

        if (datos.nombre && datos.nombre !== this._nombre) {
            this.validarNombre(datos.nombre);
            this._nombre = datos.nombre.trim();
            huboCambios = true;
        }

        if (datos.descripcion !== undefined && datos.descripcion !== this._descripcion) {
            this._descripcion = datos.descripcion?.trim() || null;
            huboCambios = true; // Nombre corregido para consistencia
        }

        if (huboCambios) {
            this._fechaModificacion = new Date();
            this._idUsuarioModificacion = datos.idUsuarioModificacion;
        }
    }

    desactivar(idUsuarioModificacion: number): void {
        if (!this._activo) {
            throw new Error('El rol ya está desactivado');
        }
        this._activo = false;
        this._fechaModificacion = new Date();
        this._idUsuarioModificacion = idUsuarioModificacion;
    }

    activar(idUsuarioModificacion: number): void {
        if (this._activo) {
            throw new Error('El rol ya está activo');
        }
        this._activo = true;
        this._fechaModificacion = new Date();
        this._idUsuarioModificacion = idUsuarioModificacion;
    }

    private validarNombre(nombre: string): void {
        if (!nombre || nombre.trim().length === 0) {
            throw new Error('El nombre del rol es requerido');
        }
        if (nombre.trim().length < 2) {
            throw new Error('El nombre del rol debe tener al menos 2 caracteres');
        }
        if (nombre.trim().length > 50) {
            throw new Error('El nombre del rol no puede exceder 50 caracteres');
        }
        const caracteresPermitidos = /^[a-zA-ZáéíóúÁÉÍÓÚñÑ\s\-_]+$/;
        if (!caracteresPermitidos.test(nombre.trim())) {
            throw new Error('El nombre del rol contiene caracteres no permitidos');
        }
    }

    puedeSerModificado(): boolean {
        return this._activo;
    }

    toString(): string {
        return `Rol[id=${this._id}, nombre=${this._nombre}, activo=${this._activo}]`;
    }
}

// ==========================================
// File: src\rol\dominio\excepciones\rol-domain.exception.ts
// ==========================================

// Clase base para todas las excepciones de dominio relacionadas con roles
export abstract class RolDomainException extends Error {
    constructor(message: string) {
        super(message);
        this.name = this.constructor.name;
    }
}

// Excepción para cuando se intenta crear un rol con un nombre que ya existe
export class RolNombreDuplicadoException extends RolDomainException {
    constructor(nombre: string) {
        super(`Ya existe un rol con el nombre "${nombre}"`);
    }
}

// Excepción para cuando se busca un rol que no existe
export class RolNoEncontradoException extends RolDomainException {
    constructor(id: number) {
        super(`No se encontró un rol con ID ${id}`);
    }
}

// Excepción para cuando se intenta operar sobre un rol inactivo
export class RolInactivoException extends RolDomainException {
    constructor(id: number) {
        super(`El rol con ID ${id} está inactivo y no puede ser modificado`);
    }
}

// Excepción para cuando se intenta eliminar un rol que tiene dependencias
export class RolConDependenciasException extends RolDomainException {
    constructor(id: number, dependencias: string[]) {
        super(`No se puede eliminar el rol con ID ${id} porque tiene dependencias en: ${dependencias.join(', ')}`);
    }
}

// Excepción para validaciones de datos de entrada
export class RolDatosInvalidosException extends RolDomainException {
    constructor(mensaje: string) {
        super(mensaje);
    }
}

// ==========================================
// File: src\rol\dominio\puertos\repositorios\rol-repositorio.interface.ts
// ==========================================

import { Rol } from '../../entidades/rol.entity';

// Esta interfaz define QUÉ necesita nuestro dominio, no CÓMO se implementa
export interface RolRepositorio {
    // Operaciones básicas CRUD
    guardar(rol: Rol): Promise<Rol>;
    buscarPorId(id: number): Promise<Rol | null>;
    buscarTodos(filtros?: {
        activo?: boolean;
        nombre?: string;
        limite?: number;
        offset?: number;
    }): Promise<Rol[]>;
    eliminar(id: number, idUsuarioEjecutor: number): Promise<void>;
    restaurar(id: number, idUsuarioEjecutor: number): Promise<void>;

    // Validaciones específicas que mencionaste
    existeConNombre(nombre: string, idExcluir?: number): Promise<boolean>;
    existeYEstaActivo(id: number): Promise<boolean>;
    puedeSerEliminado(id: number): Promise<{
        puedeEliminarse: boolean;
        razon?: string;
        dependencias?: string[];
    }>;
    contarRegistros(filtros?: { activo?: boolean }): Promise<number>;
}

// ==========================================
// File: src\rol\dominio\servicios\rol-dominio.service.ts
// ==========================================

import { Rol } from '../entidades/rol.entity';
import { RolRepositorio } from '../puertos/repositorios/rol-repositorio.interface';
import {
    RolNombreDuplicadoException,
    RolNoEncontradoException,
    RolInactivoException,
    RolConDependenciasException,
    RolDatosInvalidosException
} from '../excepciones/rol-domain.exception';

export interface ResultadoEliminacion {
    id: number;
    nombre: string;
    fechaEliminacion: Date;
    eliminadoPor: number;
}

export class RolDominioService {
    constructor(private readonly rolRepositorio: RolRepositorio) { }

    async validarNombreUnico(nombre: string, idExcluir?: number): Promise<void> {
        const existeNombre = await this.rolRepositorio.existeConNombre(nombre, idExcluir);
        if (existeNombre) {
            throw new RolNombreDuplicadoException(nombre);
        }
    }

    async validarExistenciaYEstadoActivo(id: number): Promise<Rol> {
        const rol = await this.rolRepositorio.buscarPorId(id);
        if (!rol) {
            throw new RolNoEncontradoException(id);
        }

        if (!rol.activo) {
            throw new RolInactivoException(id);
        }

        return rol;
    }

    async validarPuedeSerEliminado(id: number): Promise<void> {
        const resultadoValidacion = await this.rolRepositorio.puedeSerEliminado(id);

        if (!resultadoValidacion.puedeEliminarse) {
            throw new RolConDependenciasException(id, resultadoValidacion.dependencias || []);
        }
    }

    async crearRol(datos: {
        nombre: string;
        descripcion?: string;
        idUsuarioCreacion: number;
    }): Promise<Rol> {
        await this.validarNombreUnico(datos.nombre);

        const nuevoRol = new Rol({
            nombre: datos.nombre,
            descripcion: datos.descripcion,
            idUsuarioCreacion: datos.idUsuarioCreacion,
        });

        return await this.rolRepositorio.guardar(nuevoRol);
    }

    async actualizarRol(id: number, datos: {
        nombre?: string;
        descripcion?: string;
        idUsuarioModificacion: number;
    }): Promise<Rol> {
        const rol = await this.validarExistenciaYEstadoActivo(id);

        if (datos.nombre && datos.nombre !== rol.nombre) {
            await this.validarNombreUnico(datos.nombre, id);
        }

        rol.actualizar(datos);
        return await this.rolRepositorio.guardar(rol);
    }

    async eliminarRol(id: number, idUsuarioEjecutor: number): Promise<ResultadoEliminacion> {
        // Primero obtenemos y validamos el rol
        const rol = await this.validarExistenciaYEstadoActivo(id);

        // Guardamos la información que necesitaremos para la respuesta
        const informacionRol = {
            id: rol.id,
            nombre: rol.nombre
        };

        // Validamos que puede ser eliminado
        await this.validarPuedeSerEliminado(id);

        // Ejecutamos la eliminación
        await this.rolRepositorio.eliminar(id, idUsuarioEjecutor);

        // Devolvemos información estructurada sobre lo que se eliminó
        return {
            id: informacionRol.id,
            nombre: informacionRol.nombre,
            fechaEliminacion: new Date(),
            eliminadoPor: idUsuarioEjecutor
        };
    }

    // Nueva funcionalidad: restaurar rol eliminado
    async restaurarRol(id: number, idUsuarioEjecutor: number): Promise<Rol> {
        const rol = await this.rolRepositorio.buscarPorId(id);
        if (!rol) {
            throw new RolNoEncontradoException(id);
        }

        if (rol.activo) {
            throw new RolDatosInvalidosException(`El rol con ID ${id} ya está activo`);
        }

        // Verificamos que no haya conflicto de nombres al restaurar
        await this.validarNombreUnico(rol.nombre, id);

        await this.rolRepositorio.restaurar(id, idUsuarioEjecutor);

        // Retornamos el rol actualizado
        const rolRestaurado = await this.rolRepositorio.buscarPorId(id);
        return rolRestaurado!;
    }
}

// ==========================================
// File: src\rol\infraestructura\adaptadores\entrada\controladores\rol.controller.ts
// ==========================================

import {
    Controller,
    Get,
    Post,
    Put,
    Delete,
    Patch,
    Body,
    Param,
    Query,
    ParseIntPipe,
    HttpStatus,
    HttpCode,
} from '@nestjs/common';
import { CrearRolCasoUso } from '../../../../aplicacion/casos-uso/crear-rol.caso-uso';
import { ActualizarRolCasoUso } from '../../../../aplicacion/casos-uso/actualizar-rol.caso-uso';
import { ObtenerRolCasoUso } from '../../../../aplicacion/casos-uso/obtener-rol.caso-uso';
import { ListarRolesCasoUso, FiltrosListarRoles, TipoFiltroEstado } from '../../../../aplicacion/casos-uso/listar-roles.caso-uso';
import { EliminarRolCasoUso } from '../../../../aplicacion/casos-uso/eliminar-rol.caso-uso';
import { RestaurarRolCasoUso } from '../../../../aplicacion/casos-uso/restaurar-rol.caso-uso';
import { CrearRolDto } from '../../../../aplicacion/dtos/crear-rol.dto';
import { ActualizarRolDto } from '../../../../aplicacion/dtos/actualizar-rol.dto';

@Controller('roles')
export class RolController {
    constructor(
        private readonly crearRolCasoUso: CrearRolCasoUso,
        private readonly actualizarRolCasoUso: ActualizarRolCasoUso,
        private readonly obtenerRolCasoUso: ObtenerRolCasoUso,
        private readonly listarRolesCasoUso: ListarRolesCasoUso,
        private readonly eliminarRolCasoUso: EliminarRolCasoUso,
        private readonly restaurarRolCasoUso: RestaurarRolCasoUso, // Nueva dependencia
    ) { }

    @Post()
    @HttpCode(HttpStatus.CREATED)
    async crear(@Body() crearRolDto: CrearRolDto) {
        const idUsuarioEjecutor = 1;
        return await this.crearRolCasoUso.ejecutar(crearRolDto, idUsuarioEjecutor);
    }

    /**
     * GET /roles
     * Lista roles con filtros mejorados y paginación.
     * 
     * Ejemplos de uso mejorados:
     * - GET /roles (solo roles activos, comportamiento por defecto)
     * - GET /roles?estado=activos (explícitamente solo activos)
     * - GET /roles?estado=eliminados (solo roles eliminados/inactivos)
     * - GET /roles?estado=todos (todos los roles sin importar estado)
     * - GET /roles?estado=activos&nombre=admin (buscar "admin" solo en activos)
     * - GET /roles?limite=5&offset=10&estado=todos (paginación con todos los estados)
     */
    @Get()
    async listar(
        @Query('estado') estado?: string,
        @Query('nombre') nombre?: string,
        @Query('limite') limite?: string,
        @Query('offset') offset?: string,
    ) {
        const filtros: FiltrosListarRoles = {};

        // Validamos y convertimos el parámetro de estado
        if (estado) {
            // Verificamos que el estado solicitado sea válido
            const estadosValidos = Object.values(TipoFiltroEstado);
            if (estadosValidos.includes(estado as TipoFiltroEstado)) {
                filtros.estado = estado as TipoFiltroEstado;
            } else {
                // Si el estado no es válido, lanzamos un error específico explicando las opciones
                throw new Error(`Estado '${estado}' no válido. Estados permitidos: ${estadosValidos.join(', ')}`);
            }
        }
        // Si no se especifica estado, el caso de uso usará 'activos' por defecto

        if (nombre) {
            filtros.nombre = nombre;
        }

        // Validamos y convertimos los parámetros numéricos con límites razonables
        if (limite) {
            const limiteNum = parseInt(limite, 10);
            if (!isNaN(limiteNum) && limiteNum > 0 && limiteNum <= 100) {
                filtros.limite = limiteNum;
            } else {
                throw new Error('El límite debe ser un número entre 1 y 100');
            }
        }

        if (offset) {
            const offsetNum = parseInt(offset, 10);
            if (!isNaN(offsetNum) && offsetNum >= 0) {
                filtros.offset = offsetNum;
            } else {
                throw new Error('El offset debe ser un número mayor o igual a 0');
            }
        }

        return await this.listarRolesCasoUso.ejecutar(filtros);
    }

    @Get(':id')
    async obtenerPorId(@Param('id', ParseIntPipe) id: number) {
        return await this.obtenerRolCasoUso.ejecutar(id);
    }

    @Put(':id')
    async actualizar(
        @Param('id', ParseIntPipe) id: number,
        @Body() actualizarRolDto: ActualizarRolDto,
    ) {
        const idUsuarioEjecutor = 1;
        return await this.actualizarRolCasoUso.ejecutar(id, actualizarRolDto, idUsuarioEjecutor);
    }

    @Delete(':id')
    // Removemos el @HttpCode(HttpStatus.NO_CONTENT) para usar el 200 por defecto
    async eliminar(@Param('id', ParseIntPipe) id: number) {
        const idUsuarioEjecutor = 1;

        // Ahora devolvemos la respuesta estructurada en lugar de void
        return await this.eliminarRolCasoUso.ejecutar(id, idUsuarioEjecutor);
    }

    /**
     * PATCH /roles/:id/restaurar
     * Restaura un rol eliminado (soft delete) volviéndolo al estado activo.
     * 
     * Usamos PATCH porque estamos modificando parcialmente el estado del recurso.
     * Usamos una ruta específica (/restaurar) para que sea clara la intención.
     * 
     * Ejemplo: PATCH /roles/5/restaurar
     */
    @Patch(':id/restaurar')
    async restaurar(@Param('id', ParseIntPipe) id: number) {
        const idUsuarioEjecutor = 1;
        return await this.restaurarRolCasoUso.ejecutar(id, idUsuarioEjecutor);
    }
}

// ==========================================
// File: src\rol\infraestructura\adaptadores\salida\repositorios\mappers\rol.mapper.ts
// ==========================================

import { Rol } from '../../../../../dominio/entidades/rol.entity';
import { RolOrmEntity } from '../typeorm/entidades/rol.orm-entity';

export class RolMapper {
    /**
     * Convierte una entidad ORM de TypeORM a una entidad de dominio pura.
     * Este proceso es como traducir de "lenguaje de base de datos" a "lenguaje de negocio".
     */
    static toDomain(ormEntity: RolOrmEntity): Rol {
        return new Rol({
            id: ormEntity.id,
            nombre: ormEntity.nombre,
            descripcion: ormEntity.descripcion,
            fechaCreacion: ormEntity.fechaCreacion,
            idUsuarioCreacion: ormEntity.idUsuarioCreacion,
            fechaModificacion: ormEntity.fechaModificacion,
            idUsuarioModificacion: ormEntity.idUsuarioModificacion,
            activo: ormEntity.activo,
        });
    }

    /**
     * Convierte una entidad de dominio a una entidad ORM de TypeORM.
     * Este proceso prepara nuestros datos de negocio para ser persistidos.
     */
    static toOrm(domainEntity: Rol): RolOrmEntity {
        const ormEntity = new RolOrmEntity();

        // Solo asignamos el ID si la entidad ya fue persistida
        // Esto permite que TypeORM determine si debe hacer INSERT o UPDATE
        try {
            ormEntity.id = domainEntity.id;
        } catch (error) {
            // Si la entidad no tiene ID, TypeORM hará un INSERT
            // Si tiene ID, TypeORM hará un UPDATE
        }

        ormEntity.nombre = domainEntity.nombre;
        ormEntity.descripcion = domainEntity.descripcion;
        ormEntity.fechaCreacion = domainEntity.fechaCreacion;
        ormEntity.idUsuarioCreacion = domainEntity.idUsuarioCreacion;
        ormEntity.fechaModificacion = domainEntity.fechaModificacion;
        ormEntity.idUsuarioModificacion = domainEntity.idUsuarioModificacion;
        ormEntity.activo = domainEntity.activo;

        return ormEntity;
    }

    /**
     * Convierte un array de entidades ORM a un array de entidades de dominio.
     * Útil para operaciones de listado que devuelven múltiples registros.
     */
    static toDomainArray(ormEntities: RolOrmEntity[]): Rol[] {
        return ormEntities.map(ormEntity => this.toDomain(ormEntity));
    }
}

// ==========================================
// File: src\rol\infraestructura\adaptadores\salida\repositorios\typeorm\entidades\rol.orm-entity.ts
// ==========================================

import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';

@Entity('rol') // Este decorador le dice a TypeORM que esta clase representa la tabla 'rol'
export class RolOrmEntity {
    @PrimaryGeneratedColumn({ name: 'id' })
    id: number;

    @Column({ name: 'nombre', type: 'varchar', length: 50, nullable: false })
    nombre: string;

    @Column({ name: 'descripcion', type: 'varchar', length: 200, nullable: true })
    descripcion: string | null;

    // TypeORM puede manejar automáticamente las fechas de creación y modificación
    @CreateDateColumn({ name: 'fecha_creacion', type: 'timestamp' })
    fechaCreacion: Date;

    @Column({ name: 'id_usuario_creacion', type: 'int', nullable: true })
    idUsuarioCreacion: number | null;

    @UpdateDateColumn({ name: 'fecha_modificacion', type: 'timestamp', nullable: true })
    fechaModificacion: Date | null;

    @Column({ name: 'id_usuario_modificacion', type: 'int', nullable: true })
    idUsuarioModificacion: number | null;

    @Column({ name: 'activo', type: 'boolean', default: true })
    activo: boolean;
}

// ==========================================
// File: src\rol\infraestructura\adaptadores\salida\repositorios\typeorm\rol.repository.ts
// ==========================================

import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Like, IsNull, Not } from 'typeorm';
import { RolRepositorio } from '../../../../../dominio/puertos/repositorios/rol-repositorio.interface';
import { Rol } from '../../../../../dominio/entidades/rol.entity';
import { RolOrmEntity } from './entidades/rol.orm-entity';
import { RolMapper } from '../mappers/rol.mapper';

@Injectable() // Este decorador permite que NestJS inyecte dependencias automáticamente
export class TypeOrmRolRepository implements RolRepositorio {
    constructor(
        @InjectRepository(RolOrmEntity)
        private readonly rolRepository: Repository<RolOrmEntity>,
    ) { }

    async guardar(rol: Rol): Promise<Rol> {
        try {
            // Convertimos la entidad de dominio a entidad ORM
            const rolOrm = RolMapper.toOrm(rol);

            // TypeORM determina automáticamente si debe hacer INSERT o UPDATE
            const rolGuardado = await this.rolRepository.save(rolOrm);

            // Convertimos el resultado de vuelta a entidad de dominio
            return RolMapper.toDomain(rolGuardado);
        } catch (error) {
            // Transformamos errores de base de datos a errores de dominio más comprensibles
            if (error.code === '23505') { // Código de PostgreSQL para violación de restricción única
                throw new Error(`Ya existe un rol con el nombre especificado`);
            }
            throw new Error(`Error al guardar el rol: ${error.message}`);
        }
    }

    async buscarPorId(id: number): Promise<Rol | null> {
        const rolOrm = await this.rolRepository.findOne({
            where: { id }
        });

        return rolOrm ? RolMapper.toDomain(rolOrm) : null;
    }

    async buscarTodos(filtros: {
        activo?: boolean;
        nombre?: string;
        limite?: number;
        offset?: number;
    } = {}): Promise<Rol[]> {
        // Construimos dinámicamente las condiciones de búsqueda
        const whereConditions: any = {};

        if (filtros.activo !== undefined) {
            whereConditions.activo = filtros.activo;
        }

        if (filtros.nombre) {
            // Búsqueda parcial insensible a mayúsculas/minúsculas
            whereConditions.nombre = Like(`%${filtros.nombre}%`);
        }

        const rolesOrm = await this.rolRepository.find({
            where: whereConditions,
            take: filtros.limite || 10, // Limitamos resultados para evitar problemas de rendimiento
            skip: filtros.offset || 0,
            order: {
                nombre: 'ASC', // Ordenamos alfabéticamente por defecto
            },
        });

        return RolMapper.toDomainArray(rolesOrm);
    }

    async eliminar(id: number, idUsuarioEjecutor: number): Promise<void> {
        // Implementamos soft delete actualizando el campo 'activo'
        // Esto preserva los datos para auditoría mientras los marca como eliminados
        const resultado = await this.rolRepository.update(id, {
            activo: false,
            fechaModificacion: new Date(),
            idUsuarioModificacion: idUsuarioEjecutor,
        });

        if (resultado.affected === 0) {
            throw new Error(`No se pudo eliminar el rol con ID ${id}. Puede que no exista.`);
        }
    }

    async restaurar(id: number, idUsuarioEjecutor: number): Promise<void> {
        // Implementamos la restauración de un rol eliminado
        const resultado = await this.rolRepository.update(id, {
            activo: true,
            fechaModificacion: new Date(),
            idUsuarioModificacion: idUsuarioEjecutor,
        });

        if (resultado.affected === 0) {
            throw new Error(`No se pudo restaurar el rol con ID ${id}. Puede que no exista.`);
        }
    }

    // Implementación de las validaciones centralizadas que mencionaste anteriormente
    async existeConNombre(nombre: string, idExcluir?: number): Promise<boolean> {
        const whereConditions: any = {
            nombre: nombre.trim(),
            activo: true, // Solo consideramos roles activos para validación de unicidad
        };

        // Si estamos actualizando un rol, excluimos su propio ID de la búsqueda
        if (idExcluir) {
            whereConditions.id = Not(idExcluir);
        }

        const count = await this.rolRepository.count({
            where: whereConditions
        });

        return count > 0;
    }

    async existeYEstaActivo(id: number): Promise<boolean> {
        const count = await this.rolRepository.count({
            where: {
                id,
                activo: true
            }
        });

        return count > 0;
    }

    async puedeSerEliminado(id: number): Promise<{
        puedeEliminarse: boolean;
        razon?: string;
        dependencias?: string[];
    }> {
        const dependencias: string[] = [];

        // La única validación crítica: usuarios activos con este rol
        // Nota importante: No validamos usuarios bloqueados porque:
        // 1. Los usuarios bloqueados no pueden operar en el sistema
        // 2. Si desbloqueamos un usuario y su rol fue eliminado, podemos restaurar el rol
        // 3. Los usuarios bloqueados mantienen su relación con el rol en la BD
        const usuariosActivosConEsteRol = await this.rolRepository.manager.count('usuario', {
            where: {
                idRol: id,
                activo: true  // Solo usuarios activos importan para funcionalidad
                // Deliberadamente NO filtramos por 'bloqueado' porque como dices, no importa
            }
        });

        if (usuariosActivosConEsteRol > 0) {
            // Mensaje claro que explica exactamente por qué no se puede eliminar
            dependencias.push(`${usuariosActivosConEsteRol} usuario(s) activo(s) dependen de este rol para funcionar`);
        }

        // Si hay usuarios activos, explican claramente la razón operacional
        if (dependencias.length > 0) {
            return {
                puedeEliminarse: false,
                razon: `No se puede desactivar el rol porque interrumpiría el funcionamiento de usuarios activos`,
                dependencias
            };
        }

        // Si no hay usuarios activos, el rol se puede eliminar sin problemas operacionales
        return { puedeEliminarse: true };
    }

    async contarRegistros(filtros: { activo?: boolean } = {}): Promise<number> {
        const whereConditions: any = {};

        if (filtros.activo !== undefined) {
            whereConditions.activo = filtros.activo;
        }

        return await this.rolRepository.count({
            where: whereConditions
        });
    }
}

// ==========================================
// File: src\rol\infraestructura\config\rol.module.ts
// ==========================================

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';

// Importamos las entidades ORM para que TypeORM las reconozca
import { RolOrmEntity } from '../adaptadores/salida/repositorios/typeorm/entidades/rol.orm-entity';

// Importamos el controlador que expondrá los endpoints
import { RolController } from '../adaptadores/entrada/controladores/rol.controller';

// Importamos la implementación del repositorio
import { TypeOrmRolRepository } from '../adaptadores/salida/repositorios/typeorm/rol.repository';

// Importamos el servicio de dominio
import { RolDominioService } from '../../dominio/servicios/rol-dominio.service';

// Importamos todos los casos de uso
import { CrearRolCasoUso } from '../../aplicacion/casos-uso/crear-rol.caso-uso';
import { ActualizarRolCasoUso } from '../../aplicacion/casos-uso/actualizar-rol.caso-uso';
import { ObtenerRolCasoUso } from '../../aplicacion/casos-uso/obtener-rol.caso-uso';
import { ListarRolesCasoUso } from '../../aplicacion/casos-uso/listar-roles.caso-uso';
import { EliminarRolCasoUso } from '../../aplicacion/casos-uso/eliminar-rol.caso-uso';
import { RestaurarRolCasoUso } from 'src/rol/aplicacion/casos-uso/restaurar-rol.caso-uso';

@Module({
    // Registramos las entidades ORM para que TypeORM pueda trabajar con ellas
    imports: [
        TypeOrmModule.forFeature([RolOrmEntity])
    ],

    // Declaramos qué controladores expondrá este módulo
    controllers: [
        RolController
    ],

    // Aquí es donde ocurre la magia de la inyección de dependencias
    providers: [
        // Registramos la implementación concreta del repositorio
        // usando el patrón de token personalizado para mantener la abstracción
        {
            provide: 'RolRepositorio', // Token que usaremos para inyectar
            useClass: TypeOrmRolRepository, // Implementación concreta
        },

        // Registramos el servicio de dominio con su dependencia del repositorio
        {
            provide: RolDominioService,
            useFactory: (rolRepositorio) => {
                return new RolDominioService(rolRepositorio);
            },
            inject: ['RolRepositorio'], // Inyectamos el repositorio usando el token
        },

        // Registramos todos los casos de uso con sus respectivas dependencias
        {
            provide: CrearRolCasoUso,
            useFactory: (rolDominioService) => {
                return new CrearRolCasoUso(rolDominioService);
            },
            inject: [RolDominioService],
        },

        {
            provide: ActualizarRolCasoUso,
            useFactory: (rolDominioService) => {
                return new ActualizarRolCasoUso(rolDominioService);
            },
            inject: [RolDominioService],
        },

        {
            provide: ObtenerRolCasoUso,
            useFactory: (rolRepositorio) => {
                // Este caso de uso accede directamente al repositorio para operaciones simples
                return new ObtenerRolCasoUso(rolRepositorio);
            },
            inject: ['RolRepositorio'],
        },

        {
            provide: ListarRolesCasoUso,
            useFactory: (rolRepositorio) => {
                return new ListarRolesCasoUso(rolRepositorio);
            },
            inject: ['RolRepositorio'],
        },

        {
            provide: EliminarRolCasoUso,
            useFactory: (rolDominioService) => {
                return new EliminarRolCasoUso(rolDominioService);
            },
            inject: [RolDominioService],
        },

        {
            provide: RestaurarRolCasoUso,
            useFactory: (rolDominioService) => {
                return new RestaurarRolCasoUso(rolDominioService);
            },
            inject: [RolDominioService],
        },
    ],

    // Exportamos servicios que otros módulos podrían necesitar
    exports: [
        'RolRepositorio',
        RolDominioService,
    ],
})
export class RolModule { }

// ==========================================
// File: src\rol-permiso\aplicacion\casos-uso\obtener-gestion-permisos-rol.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { RolPermisoRepositorio } from '../../dominio/puertos/repositorios/rol-permiso-repositorio.interface';
import { GestionPermisosRolDto } from '../dtos/gestion-permisos-rol.dto';
import { RolNoValidoException } from '../../dominio/excepciones/rol-permiso-domain.exception';

export class ObtenerGestionPermisosRolCasoUso {
    private readonly logger = new Logger(ObtenerGestionPermisosRolCasoUso.name);

    constructor(
        private readonly rolPermisoRepositorio: RolPermisoRepositorio
    ) { }

    async ejecutar(idRol: number): Promise<GestionPermisosRolDto> {
        try {
            this.logger.log(`Cargando gestión de permisos para rol ID ${idRol}`);

            // Validar que el rol existe y está activo
            const rolExiste = await this.rolPermisoRepositorio.rolExisteYEstaActivo(idRol);
            if (!rolExiste) {
                throw new RolNoValidoException(idRol);
            }

            // Obtener todos los datos necesarios para la pantalla
            const gestionPermisos = await this.rolPermisoRepositorio.obtenerGestionPermisosDeRol(idRol);

            this.logger.log(
                `Gestión de permisos cargada para rol "${gestionPermisos.rol.nombre}"`,
                {
                    metricas: {
                        permisosAsignados: gestionPermisos.permisosAsignados.length,
                        permisosDisponibles: gestionPermisos.permisosDisponibles.length,
                        totalPermisos: gestionPermisos.permisosAsignados.length + gestionPermisos.permisosDisponibles.length
                    }
                }
            );

            return new GestionPermisosRolDto(gestionPermisos);

        } catch (error) {
            this.logger.error(
                `Error al cargar gestión de permisos para rol ID ${idRol}: ${error.message}`,
                {
                    contextoError: {
                        idRol,
                        tipoError: error.constructor.name,
                        operacion: 'CARGAR_GESTION_PERMISOS'
                    }
                }
            );
            throw error;
        }
    }
}

// ==========================================
// File: src\rol-permiso\aplicacion\casos-uso\sincronizar-permisos-rol.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { RolPermisoRepositorio } from '../../dominio/puertos/repositorios/rol-permiso-repositorio.interface';
import { SincronizarPermisosRolDto } from '../dtos/sincronizar-permisos-rol.dto';
import { ResultadoSincronizacionDto } from '../dtos/resultado-sincronizacion.dto';
import {
    RolNoValidoException,
    PermisoNoValidoException,
    RolPermisoDatosInvalidosException
} from '../../dominio/excepciones/rol-permiso-domain.exception';

export class SincronizarPermisosRolCasoUso {
    private readonly logger = new Logger(SincronizarPermisosRolCasoUso.name);

    constructor(
        private readonly rolPermisoRepositorio: RolPermisoRepositorio
    ) { }

    async ejecutar(
        idRol: number,
        datos: SincronizarPermisosRolDto,
        idUsuarioEjecutor: number
    ): Promise<ResultadoSincronizacionDto> {
        try {
            this.logger.log(
                `Iniciando sincronización de permisos para rol ID ${idRol}`,
                {
                    datosEntrada: {
                        idRol,
                        cantidadPermisosDeseados: datos.idsPermisosAsignados.length,
                        permisosDeseados: datos.idsPermisosAsignados,
                        idUsuarioEjecutor
                    }
                }
            );

            // 1. Validar que el rol existe y está activo
            const rolExiste = await this.rolPermisoRepositorio.rolExisteYEstaActivo(idRol);
            if (!rolExiste) {
                throw new RolNoValidoException(idRol);
            }

            // 2. Validar que todos los permisos existen y están activos
            if (datos.idsPermisosAsignados.length > 0) {
                const validacionPermisos = await this.rolPermisoRepositorio.validarPermisosExistenYActivos(
                    datos.idsPermisosAsignados
                );

                if (validacionPermisos.invalidos.length > 0) {
                    throw new RolPermisoDatosInvalidosException(
                        `Los siguientes permisos no existen o están inactivos: ${validacionPermisos.invalidos.join(', ')}`
                    );
                }
            }

            // 3. Obtener estado actual para calcular métricas
            const permisosActuales = await this.rolPermisoRepositorio.obtenerPermisosAsignadosDeRol(idRol);
            const idsPermisosActuales = permisosActuales.map(p => p.id);

            // 4. Calcular cambios
            const permisosAgregar = datos.idsPermisosAsignados.filter(id => !idsPermisosActuales.includes(id));
            const permisosRemover = idsPermisosActuales.filter(id => !datos.idsPermisosAsignados.includes(id));

            this.logger.log(
                `Análisis de cambios completado`,
                {
                    analisis: {
                        permisosActuales: idsPermisosActuales.length,
                        permisosDeseados: datos.idsPermisosAsignados.length,
                        permisosAgregar: permisosAgregar.length,
                        permisosRemover: permisosRemover.length,
                        permisosAAgregar: permisosAgregar,
                        permisosARemover: permisosRemover
                    }
                }
            );

            // 5. Ejecutar sincronización (transaccional en el repositorio)
            await this.rolPermisoRepositorio.sincronizarPermisosDeRol(
                idRol,
                datos.idsPermisosAsignados,
                idUsuarioEjecutor
            );

            // 6. Obtener nombre del rol para la respuesta
            const gestionActualizada = await this.rolPermisoRepositorio.obtenerGestionPermisosDeRol(idRol);

            this.logger.log(
                `Sincronización completada exitosamente para rol "${gestionActualizada.rol.nombre}"`,
                {
                    resultado: {
                        idRol,
                        nombreRol: gestionActualizada.rol.nombre,
                        permisosFinales: datos.idsPermisosAsignados.length,
                        permisosAgregados: permisosAgregar.length,
                        permisosRemovidos: permisosRemover.length,
                        sincronizadoPor: idUsuarioEjecutor,
                        timestamp: new Date().toISOString()
                    }
                }
            );

            return new ResultadoSincronizacionDto({
                idRol,
                nombreRol: gestionActualizada.rol.nombre,
                permisosAsignados: datos.idsPermisosAsignados.length,
                permisosRemovidos: permisosRemover.length,
                permisosAgregados: permisosAgregar.length,
                sincronizadoPor: idUsuarioEjecutor
            });

        } catch (error) {
            this.logger.error(
                `Error crítico en sincronización de permisos para rol ID ${idRol}: ${error.message}`,
                {
                    contextoError: {
                        idRol,
                        permisosIntentoAsignar: datos.idsPermisosAsignados,
                        idUsuarioEjecutor,
                        tipoError: error.constructor.name,
                        operacion: 'SINCRONIZAR_PERMISOS_ROL',
                        timestamp: new Date().toISOString()
                    }
                }
            );
            throw error;
        }
    }
}

// ==========================================
// File: src\rol-permiso\aplicacion\casos-uso\validar-permisos-para-asignacion.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { RolPermisoRepositorio } from '../../dominio/puertos/repositorios/rol-permiso-repositorio.interface';
import { RolNoValidoException } from '../../dominio/excepciones/rol-permiso-domain.exception';

export interface ResultadoValidacion {
    rolValido: boolean;
    permisosValidos: number[];
    permisosInvalidos: number[];
    advertencias: string[];
    puedeGuardar: boolean;
}

export class ValidarPermisosParaAsignacionCasoUso {
    private readonly logger = new Logger(ValidarPermisosParaAsignacionCasoUso.name);

    constructor(
        private readonly rolPermisoRepositorio: RolPermisoRepositorio
    ) { }

    async ejecutar(idRol: number, idsPermisos: number[]): Promise<ResultadoValidacion> {
        try {
            this.logger.debug(`Validando asignación de permisos para rol ID ${idRol}`, {
                idRol,
                cantidadPermisos: idsPermisos.length,
                permisos: idsPermisos
            });

            const resultado: ResultadoValidacion = {
                rolValido: false,
                permisosValidos: [],
                permisosInvalidos: [],
                advertencias: [],
                puedeGuardar: false
            };

            // 1. Validar rol
            resultado.rolValido = await this.rolPermisoRepositorio.rolExisteYEstaActivo(idRol);
            if (!resultado.rolValido) {
                resultado.advertencias.push(`El rol con ID ${idRol} no existe o está inactivo`);
                return resultado;
            }

            // 2. Validar permisos (solo si hay permisos para validar)
            if (idsPermisos.length > 0) {
                const validacionPermisos = await this.rolPermisoRepositorio.validarPermisosExistenYActivos(idsPermisos);
                resultado.permisosValidos = validacionPermisos.validos;
                resultado.permisosInvalidos = validacionPermisos.invalidos;

                if (resultado.permisosInvalidos.length > 0) {
                    resultado.advertencias.push(
                        `Los siguientes permisos no existen o están inactivos: ${resultado.permisosInvalidos.join(', ')}`
                    );
                }
            } else {
                // Si no hay permisos, significa que se quiere remover todos (válido)
                resultado.permisosValidos = [];
                resultado.permisosInvalidos = [];
            }

            // 3. Determinar si se puede guardar
            resultado.puedeGuardar = resultado.rolValido && resultado.permisosInvalidos.length === 0;

            this.logger.debug(`Validación completada`, {
                resultado: {
                    rolValido: resultado.rolValido,
                    permisosValidos: resultado.permisosValidos.length,
                    permisosInvalidos: resultado.permisosInvalidos.length,
                    puedeGuardar: resultado.puedeGuardar,
                    advertencias: resultado.advertencias.length
                }
            });

            return resultado;

        } catch (error) {
            this.logger.error(`Error en validación de permisos para rol ID ${idRol}: ${error.message}`);
            throw error;
        }
    }
}

// ==========================================
// File: src\rol-permiso\aplicacion\dtos\gestion-permisos-rol.dto.ts
// ==========================================

export class PermisoDetalleDto {
    id: number;
    codigo: string;
    nombre: string;
    descripcion: string | null; // Cambiado para consistencia

    constructor(permiso: any) {
        this.id = permiso.id;
        this.codigo = permiso.codigo;
        this.nombre = permiso.nombre;
        this.descripcion = permiso.descripcion;
    }
}

export class RolDetalleDto {
    id: number;
    nombre: string;
    descripcion: string | null; // Cambiado para consistencia

    constructor(rol: any) {
        this.id = rol.id;
        this.nombre = rol.nombre;
        this.descripcion = rol.descripcion;
    }
}

export class GestionPermisosRolDto {
    rol: RolDetalleDto;
    permisosAsignados: PermisoDetalleDto[];
    permisosDisponibles: PermisoDetalleDto[];
    totalPermisosAsignados: number;
    totalPermisosDisponibles: number;

    constructor(data: {
        rol: any;
        permisosAsignados: any[];
        permisosDisponibles: any[];
    }) {
        this.rol = new RolDetalleDto(data.rol);
        this.permisosAsignados = data.permisosAsignados.map(p => new PermisoDetalleDto(p));
        this.permisosDisponibles = data.permisosDisponibles.map(p => new PermisoDetalleDto(p));
        this.totalPermisosAsignados = this.permisosAsignados.length;
        this.totalPermisosDisponibles = this.permisosDisponibles.length;
    }
}

// ==========================================
// File: src\rol-permiso\aplicacion\dtos\resultado-sincronizacion.dto.ts
// ==========================================

export class ResultadoSincronizacionDto {
    idRol: number;
    nombreRol: string;
    permisosAsignados: number;
    permisosRemovidos: number;
    permisosAgregados: number;
    fechaSincronizacion: string;
    sincronizadoPor: number;
    mensaje: string;

    constructor(data: {
        idRol: number;
        nombreRol: string;
        permisosAsignados: number;
        permisosRemovidos: number;
        permisosAgregados: number;
        sincronizadoPor: number;
    }) {
        this.idRol = data.idRol;
        this.nombreRol = data.nombreRol;
        this.permisosAsignados = data.permisosAsignados;
        this.permisosRemovidos = data.permisosRemovidos;
        this.permisosAgregados = data.permisosAgregados;
        this.fechaSincronizacion = new Date().toISOString();
        this.sincronizadoPor = data.sincronizadoPor;
        this.mensaje = `Permisos del rol "${data.nombreRol}" sincronizados exitosamente. ${data.permisosAgregados} agregados, ${data.permisosRemovidos} removidos.`;
    }
}

// ==========================================
// File: src\rol-permiso\aplicacion\dtos\sincronizar-permisos-rol.dto.ts
// ==========================================

import { IsNotEmpty, IsArray, IsNumber, ArrayMinSize, ArrayUnique } from 'class-validator';

export class SincronizarPermisosRolDto {
    @IsNotEmpty({ message: 'La lista de permisos es requerida' })
    @IsArray({ message: 'Los permisos deben ser un array' })
    @IsNumber({}, { each: true, message: 'Cada permiso debe ser un número válido' })
    @ArrayUnique({ message: 'No se permiten permisos duplicados' })
    idsPermisosAsignados: number[];
}

// ==========================================
// File: src\rol-permiso\dominio\entidades\rol-permiso.entity.ts
// ==========================================

export class RolPermiso {
    private _id: number | undefined;
    private _idRol: number;
    private _idPermiso: number;
    private _fechaCreacion: Date;
    private _idUsuarioCreacion: number | null;
    private _fechaModificacion: Date | null;
    private _idUsuarioModificacion: number | null;
    private _activo: boolean;

    constructor(params: {
        id?: number;
        idRol: number;
        idPermiso: number;
        fechaCreacion?: Date;
        idUsuarioCreacion?: number | null;
        fechaModificacion?: Date | null;
        idUsuarioModificacion?: number | null;
        activo?: boolean;
    }) {
        this.validarIdRol(params.idRol);
        this.validarIdPermiso(params.idPermiso);

        this._id = params.id;
        this._idRol = params.idRol;
        this._idPermiso = params.idPermiso;
        this._fechaCreacion = params.fechaCreacion || new Date();
        this._idUsuarioCreacion = params.idUsuarioCreacion || null;
        this._fechaModificacion = params.fechaModificacion || null;
        this._idUsuarioModificacion = params.idUsuarioModificacion || null;
        this._activo = params.activo !== undefined ? params.activo : true;
    }

    // Getters
    get id(): number {
        if (this._id === undefined) {
            throw new Error('La asignación rol-permiso no ha sido persistida aún');
        }
        return this._id;
    }

    get idRol(): number { return this._idRol; }
    get idPermiso(): number { return this._idPermiso; }
    get fechaCreacion(): Date { return this._fechaCreacion; }
    get idUsuarioCreacion(): number | null { return this._idUsuarioCreacion; }
    get fechaModificacion(): Date | null { return this._fechaModificacion; }
    get idUsuarioModificacion(): number | null { return this._idUsuarioModificacion; }
    get activo(): boolean { return this._activo; }

    // Métodos de negocio
    desactivar(idUsuarioModificacion: number): void {
        if (!this._activo) {
            throw new Error('La asignación rol-permiso ya está desactivada');
        }
        this._activo = false;
        this._fechaModificacion = new Date();
        this._idUsuarioModificacion = idUsuarioModificacion;
    }

    activar(idUsuarioModificacion: number): void {
        if (this._activo) {
            throw new Error('La asignación rol-permiso ya está activa');
        }
        this._activo = true;
        this._fechaModificacion = new Date();
        this._idUsuarioModificacion = idUsuarioModificacion;
    }

    private validarIdRol(idRol: number): void {
        if (!idRol || idRol <= 0) {
            throw new Error('El ID del rol es requerido y debe ser mayor a 0');
        }
    }

    private validarIdPermiso(idPermiso: number): void {
        if (!idPermiso || idPermiso <= 0) {
            throw new Error('El ID del permiso es requerido y debe ser mayor a 0');
        }
    }

    toString(): string {
        return `RolPermiso[id=${this._id}, idRol=${this._idRol}, idPermiso=${this._idPermiso}, activo=${this._activo}]`;
    }
}

// ==========================================
// File: src\rol-permiso\dominio\excepciones\rol-permiso-domain.exception.ts
// ==========================================

// Clase base para todas las excepciones de dominio relacionadas con rol-permiso
export abstract class RolPermisoDomainException extends Error {
    constructor(message: string) {
        super(message);
        this.name = this.constructor.name;
    }
}

// Excepción para cuando se intenta asignar un permiso que ya está asignado
export class PermisoYaAsignnadoException extends RolPermisoDomainException {
    constructor(idRol: number, idPermiso: number) {
        super(`El permiso ${idPermiso} ya está asignado al rol ${idRol}`);
    }
}

// Excepción para cuando no se encuentra una asignación específica
export class AsignacionNoEncontradaException extends RolPermisoDomainException {
    constructor(idRol: number, idPermiso: number) {
        super(`No se encontró asignación entre rol ${idRol} y permiso ${idPermiso}`);
    }
}

// Excepción para cuando se busca un rol que no existe
export class RolNoValidoException extends RolPermisoDomainException {
    constructor(idRol: number) {
        super(`El rol con ID ${idRol} no existe o no está activo`);
    }
}

// Excepción para cuando se busca un permiso que no existe
export class PermisoNoValidoException extends RolPermisoDomainException {
    constructor(idPermiso: number) {
        super(`El permiso con ID ${idPermiso} no existe o no está activo`);
    }
}

// Excepción para validaciones de datos de entrada
export class RolPermisoDatosInvalidosException extends RolPermisoDomainException {
    constructor(mensaje: string) {
        super(mensaje);
    }
}

// ==========================================
// File: src\rol-permiso\dominio\puertos\repositorios\rol-permiso-repositorio.interface.ts
// ==========================================

import { RolPermiso } from '../../entidades/rol-permiso.entity';

// Interfaces específicas para los casos de uso frontend-oriented
export interface PermisoConDetalles {
    id: number;
    codigo: string;
    nombre: string;
    descripcion?: string | null; // Cambiado para aceptar null
}

export interface RolConDetalles {
    id: number;
    nombre: string;
    descripcion?: string | null; // Cambiado para aceptar null
}

export interface GestionPermisosRol {
    rol: RolConDetalles;
    permisosAsignados: PermisoConDetalles[];
    permisosDisponibles: PermisoConDetalles[];
}

export interface RolPermisoRepositorio {
    // Operaciones básicas CRUD
    guardar(rolPermiso: RolPermiso): Promise<RolPermiso>;
    buscarPorRolYPermiso(idRol: number, idPermiso: number): Promise<RolPermiso | null>;
    eliminar(idRol: number, idPermiso: number, idUsuarioEjecutor: number): Promise<void>;

    // Operaciones específicas para frontend
    obtenerGestionPermisosDeRol(idRol: number): Promise<GestionPermisosRol>;
    obtenerPermisosAsignadosDeRol(idRol: number): Promise<PermisoConDetalles[]>;
    obtenerPermisosDisponiblesParaRol(idRol: number): Promise<PermisoConDetalles[]>;

    // Sincronización completa (para el botón "Guardar")
    sincronizarPermisosDeRol(
        idRol: number,
        idsPermisosDeseados: number[],
        idUsuarioEjecutor: number
    ): Promise<void>;

    // Validaciones
    existeAsignacion(idRol: number, idPermiso: number): Promise<boolean>;
    rolExisteYEstaActivo(idRol: number): Promise<boolean>;
    permisoExisteYEstaActivo(idPermiso: number): Promise<boolean>;
    validarPermisosExistenYActivos(idsPermisos: number[]): Promise<{
        validos: number[];
        invalidos: number[];
    }>;
}

// ==========================================
// File: src\rol-permiso\infraestructura\adaptadores\entrada\controladores\rol-permiso.controller.ts
// ==========================================

import {
    Controller,
    Get,
    Put,
    Post,
    Body,
    Param,
    ParseIntPipe,
    HttpStatus,
    HttpCode,
} from '@nestjs/common';
import { ObtenerGestionPermisosRolCasoUso } from '../../../../aplicacion/casos-uso/obtener-gestion-permisos-rol.caso-uso';
import { SincronizarPermisosRolCasoUso } from '../../../../aplicacion/casos-uso/sincronizar-permisos-rol.caso-uso';
import { ValidarPermisosParaAsignacionCasoUso } from '../../../../aplicacion/casos-uso/validar-permisos-para-asignacion.caso-uso';
import { SincronizarPermisosRolDto } from '../../../../aplicacion/dtos/sincronizar-permisos-rol.dto';

@Controller('roles')
export class RolPermisoController {
    constructor(
        private readonly obtenerGestionPermisosRolCasoUso: ObtenerGestionPermisosRolCasoUso,
        private readonly sincronizarPermisosRolCasoUso: SincronizarPermisosRolCasoUso,
        private readonly validarPermisosParaAsignacionCasoUso: ValidarPermisosParaAsignacionCasoUso,
    ) { }

    /**
     * GET /roles/:idRol/gestion-permisos
     * Obtiene toda la información necesaria para la pantalla de gestión de permisos.
     * Retorna el rol, permisos asignados y permisos disponibles.
     * 
     * Ejemplo: GET /roles/1/gestion-permisos
     */
    @Get(':idRol/gestion-permisos')
    async obtenerGestionPermisos(@Param('idRol', ParseIntPipe) idRol: number) {
        return await this.obtenerGestionPermisosRolCasoUso.ejecutar(idRol);
    }

    /**
     * PUT /roles/:idRol/permisos
     * Sincroniza todos los permisos del rol de una vez.
     * Recibe un array con los IDs de permisos que deben quedar asignados.
     * Elimina los no incluidos y agrega los nuevos.
     * 
     * Ejemplo: PUT /roles/1/permisos
     * Body: { "idsPermisosAsignados": [1, 3, 5, 7] }
     */
    @Put(':idRol/permisos')
    @HttpCode(HttpStatus.OK)
    async sincronizarPermisos(
        @Param('idRol', ParseIntPipe) idRol: number,
        @Body() sincronizarPermisosDto: SincronizarPermisosRolDto,
    ) {
        const idUsuarioEjecutor = 1; // TODO: Obtener del contexto de autenticación
        return await this.sincronizarPermisosRolCasoUso.ejecutar(
            idRol,
            sincronizarPermisosDto,
            idUsuarioEjecutor
        );
    }

    /**
     * POST /roles/:idRol/permisos/validar
     * Valida si los permisos pueden ser asignados al rol.
     * Útil para validaciones en tiempo real en el frontend.
     * 
     * Ejemplo: POST /roles/1/permisos/validar
     * Body: { "idsPermisosAsignados": [1, 3, 5, 999] }
     */
    @Post(':idRol/permisos/validar')
    @HttpCode(HttpStatus.OK)
    async validarPermisos(
        @Param('idRol', ParseIntPipe) idRol: number,
        @Body() datos: { idsPermisosAsignados: number[] },
    ) {
        // Validar que el body tenga la estructura esperada
        if (!Array.isArray(datos.idsPermisosAsignados)) {
            throw new Error('Se requiere un array de IDs de permisos');
        }

        return await this.validarPermisosParaAsignacionCasoUso.ejecutar(
            idRol,
            datos.idsPermisosAsignados
        );
    }
}

// ==========================================
// File: src\rol-permiso\infraestructura\adaptadores\salida\repositorios\mappers\rol-permiso.mapper.ts
// ==========================================

import { RolPermiso } from '../../../../../dominio/entidades/rol-permiso.entity';
import { RolPermisoOrmEntity } from '../typeorm/entidades/rol-permiso.orm-entity';

export class RolPermisoMapper {
    /**
     * Convierte una entidad ORM de TypeORM a una entidad de dominio pura.
     */
    static toDomain(ormEntity: RolPermisoOrmEntity): RolPermiso {
        return new RolPermiso({
            id: ormEntity.id,
            idRol: ormEntity.idRol,
            idPermiso: ormEntity.idPermiso,
            fechaCreacion: ormEntity.fechaCreacion,
            idUsuarioCreacion: ormEntity.idUsuarioCreacion,
            fechaModificacion: ormEntity.fechaModificacion,
            idUsuarioModificacion: ormEntity.idUsuarioModificacion,
            activo: ormEntity.activo,
        });
    }

    /**
     * Convierte una entidad de dominio a una entidad ORM de TypeORM.
     */
    static toOrm(domainEntity: RolPermiso): RolPermisoOrmEntity {
        const ormEntity = new RolPermisoOrmEntity();

        // Solo asignamos el ID si la entidad ya fue persistida
        try {
            ormEntity.id = domainEntity.id;
        } catch (error) {
            // Si la entidad no tiene ID, TypeORM hará un INSERT
        }

        ormEntity.idRol = domainEntity.idRol;
        ormEntity.idPermiso = domainEntity.idPermiso;
        ormEntity.fechaCreacion = domainEntity.fechaCreacion;
        ormEntity.idUsuarioCreacion = domainEntity.idUsuarioCreacion;
        ormEntity.fechaModificacion = domainEntity.fechaModificacion;
        ormEntity.idUsuarioModificacion = domainEntity.idUsuarioModificacion;
        ormEntity.activo = domainEntity.activo;

        return ormEntity;
    }

    /**
     * Convierte un array de entidades ORM a un array de entidades de dominio.
     */
    static toDomainArray(ormEntities: RolPermisoOrmEntity[]): RolPermiso[] {
        return ormEntities.map(ormEntity => this.toDomain(ormEntity));
    }
}

// ==========================================
// File: src\rol-permiso\infraestructura\adaptadores\salida\repositorios\typeorm\entidades\rol-permiso.orm-entity.ts
// ==========================================

import { PermisoOrmEntity } from 'src/permiso/infraestructura/adaptadores/salida/repositorios/typeorm/entidades/permiso.orm-entity';
import { RolOrmEntity } from 'src/rol/infraestructura/adaptadores/salida/repositorios/typeorm/entidades/rol.orm-entity';
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, ManyToOne, JoinColumn } from 'typeorm';

@Entity('rol_permiso')
export class RolPermisoOrmEntity {
    @PrimaryGeneratedColumn({ name: 'id' })
    id: number;

    @Column({ name: 'id_rol', type: 'int', nullable: false })
    idRol: number;

    @Column({ name: 'id_permiso', type: 'int', nullable: false })
    idPermiso: number;

    @CreateDateColumn({ name: 'fecha_creacion', type: 'timestamp' })
    fechaCreacion: Date;

    @Column({ name: 'id_usuario_creacion', type: 'int', nullable: true })
    idUsuarioCreacion: number | null;

    @UpdateDateColumn({ name: 'fecha_modificacion', type: 'timestamp', nullable: true })
    fechaModificacion: Date | null;

    @Column({ name: 'id_usuario_modificacion', type: 'int', nullable: true })
    idUsuarioModificacion: number | null;

    @Column({ name: 'activo', type: 'boolean', default: true })
    activo: boolean;

    // Relaciones para joins (opcional, útil para consultas complejas)
    @ManyToOne(() => RolOrmEntity)
    @JoinColumn({ name: 'id_rol' })
    rol?: RolOrmEntity;

    @ManyToOne(() => PermisoOrmEntity)
    @JoinColumn({ name: 'id_permiso' })
    permiso?: PermisoOrmEntity;
}

// ==========================================
// File: src\rol-permiso\infraestructura\adaptadores\salida\repositorios\typeorm\rol-permiso.repository.ts
// ==========================================

import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { RolPermisoRepositorio, GestionPermisosRol, PermisoConDetalles, RolConDetalles } from '../../../../../dominio/puertos/repositorios/rol-permiso-repositorio.interface';
import { RolPermiso } from '../../../../../dominio/entidades/rol-permiso.entity';
import { RolPermisoOrmEntity } from './entidades/rol-permiso.orm-entity';
import { RolOrmEntity } from '../../../../../../rol/infraestructura/adaptadores/salida/repositorios/typeorm/entidades/rol.orm-entity';
import { PermisoOrmEntity } from '../../../../../../permiso/infraestructura/adaptadores/salida/repositorios/typeorm/entidades/permiso.orm-entity';
import { RolPermisoMapper } from '../mappers/rol-permiso.mapper';

@Injectable()
export class TypeOrmRolPermisoRepository implements RolPermisoRepositorio {
    constructor(
        @InjectRepository(RolPermisoOrmEntity)
        private readonly rolPermisoRepository: Repository<RolPermisoOrmEntity>,
        @InjectRepository(RolOrmEntity)
        private readonly rolRepository: Repository<RolOrmEntity>,
        @InjectRepository(PermisoOrmEntity)
        private readonly permisoRepository: Repository<PermisoOrmEntity>,
    ) { }

    async guardar(rolPermiso: RolPermiso): Promise<RolPermiso> {
        try {
            const rolPermisoOrm = RolPermisoMapper.toOrm(rolPermiso);
            const rolPermisoGuardado = await this.rolPermisoRepository.save(rolPermisoOrm);
            return RolPermisoMapper.toDomain(rolPermisoGuardado);
        } catch (error) {
            if (error.code === '23505') {
                throw new Error(`La asignación rol-permiso ya existe`);
            }
            throw new Error(`Error al guardar la asignación rol-permiso: ${error.message}`);
        }
    }

    async buscarPorRolYPermiso(idRol: number, idPermiso: number): Promise<RolPermiso | null> {
        const rolPermisoOrm = await this.rolPermisoRepository.findOne({
            where: { idRol, idPermiso }
        });

        return rolPermisoOrm ? RolPermisoMapper.toDomain(rolPermisoOrm) : null;
    }

    async eliminar(idRol: number, idPermiso: number, idUsuarioEjecutor: number): Promise<void> {
        const resultado = await this.rolPermisoRepository.update(
            { idRol, idPermiso },
            {
                activo: false,
                fechaModificacion: new Date(),
                idUsuarioModificacion: idUsuarioEjecutor,
            }
        );

        if (resultado.affected === 0) {
            throw new Error(`No se pudo eliminar la asignación rol ${idRol} - permiso ${idPermiso}`);
        }
    }

    async obtenerGestionPermisosDeRol(idRol: number): Promise<GestionPermisosRol> {
        // Obtener información del rol
        const rol = await this.rolRepository.findOne({
            where: { id: idRol, activo: true }
        });

        if (!rol) {
            throw new Error(`Rol con ID ${idRol} no encontrado o inactivo`);
        }

        // Obtener permisos asignados al rol
        const permisosAsignados = await this.permisoRepository
            .createQueryBuilder('permiso')
            .innerJoin('rol_permiso', 'rp', 'rp.id_permiso = permiso.id')
            .where('rp.id_rol = :idRol', { idRol })
            .andWhere('rp.activo = true')
            .andWhere('permiso.activo = true')
            .orderBy('permiso.codigo', 'ASC')
            .getMany();

        // Obtener permisos disponibles (no asignados al rol)
        const permisosDisponibles = await this.permisoRepository
            .createQueryBuilder('permiso')
            .leftJoin(
                'rol_permiso',
                'rp',
                'rp.id_permiso = permiso.id AND rp.id_rol = :idRol AND rp.activo = true',
                { idRol }
            )
            .where('permiso.activo = true')
            .andWhere('rp.id IS NULL')
            .orderBy('permiso.codigo', 'ASC')
            .getMany();

        return {
            rol: {
                id: rol.id,
                nombre: rol.nombre,
                descripcion: rol.descripcion
            },
            permisosAsignados: permisosAsignados.map(p => ({
                id: p.id,
                codigo: p.codigo,
                nombre: p.nombre,
                descripcion: p.descripcion
            })),
            permisosDisponibles: permisosDisponibles.map(p => ({
                id: p.id,
                codigo: p.codigo,
                nombre: p.nombre,
                descripcion: p.descripcion
            }))
        };
    }

    async obtenerPermisosAsignadosDeRol(idRol: number): Promise<PermisoConDetalles[]> {
        const permisos = await this.permisoRepository
            .createQueryBuilder('permiso')
            .innerJoin('rol_permiso', 'rp', 'rp.id_permiso = permiso.id')
            .where('rp.id_rol = :idRol', { idRol })
            .andWhere('rp.activo = true')
            .andWhere('permiso.activo = true')
            .orderBy('permiso.codigo', 'ASC')
            .getMany();

        return permisos.map(p => ({
            id: p.id,
            codigo: p.codigo,
            nombre: p.nombre,
            descripcion: p.descripcion
        }));
    }

    async obtenerPermisosDisponiblesParaRol(idRol: number): Promise<PermisoConDetalles[]> {
        const permisos = await this.permisoRepository
            .createQueryBuilder('permiso')
            .leftJoin(
                'rol_permiso',
                'rp',
                'rp.id_permiso = permiso.id AND rp.id_rol = :idRol AND rp.activo = true',
                { idRol }
            )
            .where('permiso.activo = true')
            .andWhere('rp.id IS NULL')
            .orderBy('permiso.codigo', 'ASC')
            .getMany();

        return permisos.map(p => ({
            id: p.id,
            codigo: p.codigo,
            nombre: p.nombre,
            descripcion: p.descripcion
        }));
    }

    async sincronizarPermisosDeRol(
        idRol: number,
        idsPermisosDeseados: number[],
        idUsuarioEjecutor: number
    ): Promise<void> {
        // Usar transacción para asegurar consistencia
        await this.rolPermisoRepository.manager.transaction(async transactionalEntityManager => {

            // 1. Desactivar todas las asignaciones actuales del rol
            await transactionalEntityManager.update(
                RolPermisoOrmEntity,
                { idRol, activo: true },
                {
                    activo: false,
                    fechaModificacion: new Date(),
                    idUsuarioModificacion: idUsuarioEjecutor
                }
            );

            // 2. Crear nuevas asignaciones para los permisos deseados
            if (idsPermisosDeseados.length > 0) {
                const nuevasAsignaciones = idsPermisosDeseados.map(idPermiso => ({
                    idRol,
                    idPermiso,
                    fechaCreacion: new Date(),
                    idUsuarioCreacion: idUsuarioEjecutor,
                    activo: true
                }));

                await transactionalEntityManager.save(RolPermisoOrmEntity, nuevasAsignaciones);
            }
        });
    }

    async existeAsignacion(idRol: number, idPermiso: number): Promise<boolean> {
        const count = await this.rolPermisoRepository.count({
            where: { idRol, idPermiso, activo: true }
        });
        return count > 0;
    }

    async rolExisteYEstaActivo(idRol: number): Promise<boolean> {
        const count = await this.rolRepository.count({
            where: { id: idRol, activo: true }
        });
        return count > 0;
    }

    async permisoExisteYEstaActivo(idPermiso: number): Promise<boolean> {
        const count = await this.permisoRepository.count({
            where: { id: idPermiso, activo: true }
        });
        return count > 0;
    }

    async validarPermisosExistenYActivos(idsPermisos: number[]): Promise<{
        validos: number[];
        invalidos: number[];
    }> {
        if (idsPermisos.length === 0) {
            return { validos: [], invalidos: [] };
        }

        const permisosExistentes = await this.permisoRepository.find({
            where: { activo: true },
            select: ['id']
        });

        const idsPermisosExistentes = permisosExistentes.map(p => p.id);

        const validos = idsPermisos.filter(id => idsPermisosExistentes.includes(id));
        const invalidos = idsPermisos.filter(id => !idsPermisosExistentes.includes(id));

        return { validos, invalidos };
    }
}

// ==========================================
// File: src\rol-permiso\infraestructura\config\rol-permiso.module.ts
// ==========================================

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';

// Importamos las entidades ORM necesarias
import { RolPermisoOrmEntity } from '../adaptadores/salida/repositorios/typeorm/entidades/rol-permiso.orm-entity';
import { RolOrmEntity } from '../../../rol/infraestructura/adaptadores/salida/repositorios/typeorm/entidades/rol.orm-entity';
import { PermisoOrmEntity } from '../../../permiso/infraestructura/adaptadores/salida/repositorios/typeorm/entidades/permiso.orm-entity';

// Importamos el controlador
import { RolPermisoController } from '../adaptadores/entrada/controladores/rol-permiso.controller';

// Importamos la implementación del repositorio
import { TypeOrmRolPermisoRepository } from '../adaptadores/salida/repositorios/typeorm/rol-permiso.repository';

// Importamos todos los casos de uso
import { ObtenerGestionPermisosRolCasoUso } from '../../aplicacion/casos-uso/obtener-gestion-permisos-rol.caso-uso';
import { SincronizarPermisosRolCasoUso } from '../../aplicacion/casos-uso/sincronizar-permisos-rol.caso-uso';
import { ValidarPermisosParaAsignacionCasoUso } from '../../aplicacion/casos-uso/validar-permisos-para-asignacion.caso-uso';

@Module({
    // Registramos todas las entidades ORM que necesitamos
    imports: [
        TypeOrmModule.forFeature([
            RolPermisoOrmEntity,
            RolOrmEntity,
            PermisoOrmEntity
        ])
    ],

    // Declaramos el controlador
    controllers: [
        RolPermisoController
    ],

    // Configuramos la inyección de dependencias
    providers: [
        // Registramos la implementación del repositorio
        {
            provide: 'RolPermisoRepositorio',
            useClass: TypeOrmRolPermisoRepository,
        },

        // Registramos los casos de uso
        {
            provide: ObtenerGestionPermisosRolCasoUso,
            useFactory: (rolPermisoRepositorio) => {
                return new ObtenerGestionPermisosRolCasoUso(rolPermisoRepositorio);
            },
            inject: ['RolPermisoRepositorio'],
        },

        {
            provide: SincronizarPermisosRolCasoUso,
            useFactory: (rolPermisoRepositorio) => {
                return new SincronizarPermisosRolCasoUso(rolPermisoRepositorio);
            },
            inject: ['RolPermisoRepositorio'],
        },

        {
            provide: ValidarPermisosParaAsignacionCasoUso,
            useFactory: (rolPermisoRepositorio) => {
                return new ValidarPermisosParaAsignacionCasoUso(rolPermisoRepositorio);
            },
            inject: ['RolPermisoRepositorio'],
        },
    ],

    // Exportamos servicios que otros módulos podrían necesitar
    exports: [
        'RolPermisoRepositorio',
    ],
})
export class RolPermisoModule { }

// ==========================================
// File: src\usuario\aplicacion\casos-uso\actualizar-usuario.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { UsuarioDominioService } from '../../dominio/servicios/usuario-dominio.service';
import { ActualizarUsuarioDto } from '../dtos/actualizar-usuario.dto';
import { UsuarioRespuestaDto } from '../dtos/usuario-respuesta.dto';

export class ActualizarUsuarioCasoUso {
    private readonly logger = new Logger(ActualizarUsuarioCasoUso.name);

    constructor(
        private readonly usuarioDominioService: UsuarioDominioService
    ) { }

    async ejecutar(
        id: number,
        datos: ActualizarUsuarioDto,
        idUsuarioEjecutor: number
    ): Promise<UsuarioRespuestaDto> {
        try {
            const camposAActualizar = Object.keys(datos).filter(key => datos[key] !== undefined);
            this.logger.log(
                `Iniciando actualización de usuario ID ${id} por usuario ${idUsuarioEjecutor}`,
                { camposAActualizar }
            );

            const usuarioActualizado = await this.usuarioDominioService.actualizarUsuario(id, {
                idRol: datos.idRol,
                bloqueado: datos.bloqueado,
                idUsuarioModificacion: idUsuarioEjecutor
            });

            this.logger.log(
                `Usuario actualizado exitosamente: ID ${id}`,
                {
                    rolAnterior: datos.idRol ? 'actualizado' : 'sin cambios',
                    bloqueoAnterior: datos.bloqueado !== undefined ? 'actualizado' : 'sin cambios'
                }
            );

            return new UsuarioRespuestaDto(usuarioActualizado);

        } catch (error) {
            this.logger.error(
                `Error al actualizar usuario ID ${id}: ${error.message}`,
                {
                    datosEntrada: {
                        camposEnviados: Object.keys(datos),
                        idUsuario: id
                    },
                    idUsuarioEjecutor,
                    tipoError: error.constructor.name
                }
            );
            throw error;
        }
    }
}

// ==========================================
// File: src\usuario\aplicacion\casos-uso\bloquear-usuario.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { UsuarioDominioService } from '../../dominio/servicios/usuario-dominio.service';
import { UsuarioRespuestaDto } from '../dtos/usuario-respuesta.dto';

export class BloquearUsuarioCasoUso {
    private readonly logger = new Logger(BloquearUsuarioCasoUso.name);

    constructor(
        private readonly usuarioDominioService: UsuarioDominioService
    ) { }

    async ejecutar(id: number, idUsuarioEjecutor: number): Promise<UsuarioRespuestaDto> {
        try {
            this.logger.log(
                `Iniciando bloqueo de usuario ID ${id} por usuario ${idUsuarioEjecutor}`,
                {
                    operacionBloqueo: {
                        idUsuario: id,
                        idUsuarioEjecutor,
                        timestamp: new Date().toISOString(),
                        razonOperacion: 'BLOQUEAR_USUARIO'
                    }
                }
            );

            const usuarioBloqueado = await this.usuarioDominioService.bloquearUsuario(id, idUsuarioEjecutor);

            this.logger.log(
                `Usuario bloqueado exitosamente: ID ${id}, username: "${usuarioBloqueado.username}"`,
                {
                    resultadoBloqueo: {
                        idUsuario: usuarioBloqueado.id,
                        usernameUsuario: usuarioBloqueado.username,
                        bloqueadoPor: idUsuarioEjecutor,
                        estadoFinal: 'BLOQUEADO',
                        fechaBloqueo: new Date().toISOString()
                    }
                }
            );

            return new UsuarioRespuestaDto(usuarioBloqueado);

        } catch (error) {
            this.logger.error(
                `Error al bloquear usuario ID ${id}: ${error.message}`,
                {
                    contextoError: {
                        idUsuario: id,
                        idUsuarioEjecutor,
                        tipoError: error.constructor.name,
                        operacionFallida: 'BLOQUEAR_USUARIO'
                    }
                }
            );
            throw error;
        }
    }
}

// ==========================================
// File: src\usuario\aplicacion\casos-uso\cambiar-password.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { UsuarioDominioService } from '../../dominio/servicios/usuario-dominio.service';
import { CambiarPasswordDto } from '../dtos/cambiar-password.dto';
import { UsuarioRespuestaDto } from '../dtos/usuario-respuesta.dto';
import * as bcrypt from 'bcrypt';

export class CambiarPasswordCasoUso {
    private readonly logger = new Logger(CambiarPasswordCasoUso.name);

    constructor(
        private readonly usuarioDominioService: UsuarioDominioService
    ) { }

    async ejecutar(
        id: number,
        datos: CambiarPasswordDto,
        idUsuarioEjecutor: number
    ): Promise<UsuarioRespuestaDto> {
        try {
            this.logger.log(`Iniciando cambio de contraseña para usuario ID ${id} por usuario ${idUsuarioEjecutor}`);

            // Hashear la nueva contraseña
            const saltRounds = 12;
            const nuevaPasswordHash = await bcrypt.hash(datos.nuevaPassword, saltRounds);

            const usuarioActualizado = await this.usuarioDominioService.cambiarPassword(id, {
                nuevaPasswordHash,
                idUsuarioModificacion: idUsuarioEjecutor
            });

            this.logger.log(`Contraseña cambiada exitosamente para usuario ID ${id}`);

            return new UsuarioRespuestaDto(usuarioActualizado);

        } catch (error) {
            this.logger.error(
                `Error al cambiar contraseña para usuario ID ${id}: ${error.message}`,
                {
                    idUsuario: id,
                    idUsuarioEjecutor,
                    tipoError: error.constructor.name
                }
            );
            throw error;
        }
    }
}

// ==========================================
// File: src\usuario\aplicacion\casos-uso\crear-usuario.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { UsuarioDominioService } from '../../dominio/servicios/usuario-dominio.service';
import { CrearUsuarioDto } from '../dtos/crear-usuario.dto';
import { UsuarioRespuestaDto } from '../dtos/usuario-respuesta.dto';
import * as bcrypt from 'bcrypt';

export class CrearUsuarioCasoUso {
    private readonly logger = new Logger(CrearUsuarioCasoUso.name);

    constructor(
        private readonly usuarioDominioService: UsuarioDominioService
    ) { }

    async ejecutar(datos: CrearUsuarioDto, idUsuarioEjecutor: number): Promise<UsuarioRespuestaDto> {
        try {
            this.logger.log(`Iniciando creación de usuario: "${datos.username}" para persona ID ${datos.idPersona} por usuario ${idUsuarioEjecutor}`);

            // Hashear la contraseña antes de enviar al dominio
            const saltRounds = 12;
            const passwordHash = await bcrypt.hash(datos.password, saltRounds);

            const usuarioCreado = await this.usuarioDominioService.crearUsuario({
                idPersona: datos.idPersona,
                idRol: datos.idRol,
                username: datos.username,
                passwordHash,
                idUsuarioCreacion: idUsuarioEjecutor
            });

            this.logger.log(`Usuario creado exitosamente: ID ${usuarioCreado.id}, username: "${usuarioCreado.username}"`);

            return new UsuarioRespuestaDto(usuarioCreado);

        } catch (error) {
            this.logger.error(
                `Error al crear usuario: ${error.message}`,
                {
                    datosEntrada: {
                        username: datos.username,
                        idPersona: datos.idPersona,
                        idRol: datos.idRol
                    },
                    idUsuarioEjecutor,
                    tipoError: error.constructor.name,
                }
            );
            throw error;
        }
    }
}

// ==========================================
// File: src\usuario\aplicacion\casos-uso\desbloquear-usuario.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { UsuarioDominioService } from '../../dominio/servicios/usuario-dominio.service';
import { UsuarioRespuestaDto } from '../dtos/usuario-respuesta.dto';

export class DesbloquearUsuarioCasoUso {
    private readonly logger = new Logger(DesbloquearUsuarioCasoUso.name);

    constructor(
        private readonly usuarioDominioService: UsuarioDominioService
    ) { }

    async ejecutar(id: number, idUsuarioEjecutor: number): Promise<UsuarioRespuestaDto> {
        try {
            this.logger.log(
                `Iniciando desbloqueo de usuario ID ${id} por usuario ${idUsuarioEjecutor}`,
                {
                    operacionDesbloqueo: {
                        idUsuario: id,
                        idUsuarioEjecutor,
                        timestamp: new Date().toISOString(),
                        razonOperacion: 'DESBLOQUEAR_USUARIO'
                    }
                }
            );

            const usuarioDesbloqueado = await this.usuarioDominioService.desbloquearUsuario(id, idUsuarioEjecutor);

            this.logger.log(
                `Usuario desbloqueado exitosamente: ID ${id}, username: "${usuarioDesbloqueado.username}"`,
                {
                    resultadoDesbloqueo: {
                        idUsuario: usuarioDesbloqueado.id,
                        usernameUsuario: usuarioDesbloqueado.username,
                        desbloqueadoPor: idUsuarioEjecutor,
                        estadoFinal: 'ACTIVO_NO_BLOQUEADO',
                        fechaDesbloqueo: new Date().toISOString()
                    }
                }
            );

            return new UsuarioRespuestaDto(usuarioDesbloqueado);

        } catch (error) {
            this.logger.error(
                `Error al desbloquear usuario ID ${id}: ${error.message}`,
                {
                    contextoError: {
                        idUsuario: id,
                        idUsuarioEjecutor,
                        tipoError: error.constructor.name,
                        operacionFallida: 'DESBLOQUEAR_USUARIO'
                    }
                }
            );
            throw error;
        }
    }
}

// ==========================================
// File: src\usuario\aplicacion\casos-uso\eliminar-usuario.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { UsuarioDominioService, ResultadoEliminacion } from '../../dominio/servicios/usuario-dominio.service';

export class UsuarioEliminadoDto {
    id: number;
    username: string;
    nombreCompleto: string;
    eliminadoPor: number;
    fechaEliminacion: string;
    mensaje: string;

    constructor(resultado: ResultadoEliminacion) {
        this.id = resultado.id;
        this.username = resultado.username;
        this.nombreCompleto = resultado.nombreCompleto;
        this.eliminadoPor = resultado.eliminadoPor;
        this.fechaEliminacion = resultado.fechaEliminacion.toISOString();
        this.mensaje = `El usuario "${resultado.username}" (${resultado.nombreCompleto}) ha sido eliminado exitosamente`;
    }
}

export class EliminarUsuarioCasoUso {
    private readonly logger = new Logger(EliminarUsuarioCasoUso.name);

    constructor(
        private readonly usuarioDominioService: UsuarioDominioService
    ) { }

    async ejecutar(id: number, idUsuarioEjecutor: number): Promise<UsuarioEliminadoDto> {
        try {
            this.logger.log(
                `Iniciando eliminación (soft delete) de usuario ID ${id}`,
                {
                    auditoria: {
                        idUsuario: id,
                        idUsuarioEjecutor,
                        timestamp: new Date().toISOString(),
                        operacion: 'ELIMINAR_USUARIO'
                    }
                }
            );

            const resultadoEliminacion = await this.usuarioDominioService.eliminarUsuario(id, idUsuarioEjecutor);

            this.logger.log(
                `Usuario eliminado exitosamente: ID ${resultadoEliminacion.id}, username: "${resultadoEliminacion.username}"`,
                {
                    resultado: {
                        idUsuario: resultadoEliminacion.id,
                        usernameUsuario: resultadoEliminacion.username,
                        nombreCompleto: resultadoEliminacion.nombreCompleto,
                        estadoFinal: 'ELIMINADO',
                        eliminadoPor: resultadoEliminacion.eliminadoPor,
                        tipoEliminacion: 'SOFT_DELETE',
                        fechaEliminacion: resultadoEliminacion.fechaEliminacion.toISOString()
                    }
                }
            );

            return new UsuarioEliminadoDto(resultadoEliminacion);

        } catch (error) {
            this.logger.error(
                `Error crítico al eliminar usuario ID ${id}: ${error.message}`,
                {
                    contextoError: {
                        idUsuario: id,
                        idUsuarioEjecutor,
                        tipoError: error.constructor.name,
                        momentoFallo: new Date().toISOString(),
                        operacionFallida: 'ELIMINAR_USUARIO'
                    }
                }
            );
            throw error;
        }
    }
}

// ==========================================
// File: src\usuario\aplicacion\casos-uso\listar-usuarios.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { UsuarioRepositorio } from '../../dominio/puertos/repositorios/usuario-repositorio.interface';
import { UsuarioConDetallesDto } from '../dtos/usuario-con-detalles.dto';

export enum TipoFiltroEstado {
    ACTIVOS = 'activos',
    ELIMINADOS = 'eliminados',
    TODOS = 'todos'
}

export enum TipoFiltroBloqueado {
    BLOQUEADOS = 'bloqueados',
    NO_BLOQUEADOS = 'no_bloqueados',
    TODOS = 'todos'
}

export interface FiltrosListarUsuarios {
    estado?: TipoFiltroEstado;
    bloqueado?: TipoFiltroBloqueado;
    idRol?: number;
    username?: string;
    limite?: number;
    offset?: number;
}

export interface ResultadoPaginado<T> {
    datos: T[];
    total: number;
    limite: number;
    offset: number;
    totalPaginas: number;
    paginaActual: number;
    filtrosAplicados: {
        estado: TipoFiltroEstado;
        bloqueado: TipoFiltroBloqueado;
        idRol?: number;
        username?: string;
    };
}

export class ListarUsuariosCasoUso {
    private readonly logger = new Logger(ListarUsuariosCasoUso.name);

    constructor(
        private readonly usuarioRepositorio: UsuarioRepositorio
    ) { }

    async ejecutar(filtros: FiltrosListarUsuarios = {}): Promise<ResultadoPaginado<UsuarioConDetallesDto>> {
        try {
            const limite = filtros.limite || 10;
            const offset = filtros.offset || 0;
            const estado = filtros.estado || TipoFiltroEstado.ACTIVOS;
            const bloqueado = filtros.bloqueado || TipoFiltroBloqueado.TODOS;

            this.logger.log('Listando usuarios', {
                filtros: {
                    estado,
                    bloqueado,
                    idRol: filtros.idRol || 'sin filtro',
                    username: filtros.username || 'sin filtro',
                    paginacion: { limite, offset }
                }
            });

            const filtrosRepositorio = this.convertirFiltrosParaRepositorio(filtros, estado, bloqueado);

            const [usuarios, total] = await Promise.all([
                this.usuarioRepositorio.listarConDetalles(filtrosRepositorio),
                this.usuarioRepositorio.contarRegistros(this.getFiltrosConteo(estado, bloqueado))
            ]);

            this.logger.log(
                `Consulta de usuarios completada: ${usuarios.length} usuarios obtenidos de ${total} totales`,
                {
                    metricas: {
                        resultadosEncontrados: usuarios.length,
                        totalDisponible: total,
                        filtroEstado: estado,
                        filtroBloqueado: bloqueado,
                        tiempoRespuesta: 'rápido'
                    }
                }
            );

            const usuariosDto = usuarios.map(usuario => new UsuarioConDetallesDto(usuario));
            const totalPaginas = Math.ceil(total / limite);
            const paginaActual = Math.floor(offset / limite) + 1;

            return {
                datos: usuariosDto,
                total,
                limite,
                offset,
                totalPaginas,
                paginaActual,
                filtrosAplicados: {
                    estado,
                    bloqueado,
                    idRol: filtros.idRol,
                    username: filtros.username
                }
            };

        } catch (error) {
            this.logger.error(
                `Error al listar usuarios: ${error.message}`,
                {
                    filtrosAplicados: filtros,
                    tipoError: error.constructor.name
                }
            );
            throw error;
        }
    }

    private convertirFiltrosParaRepositorio(filtros: FiltrosListarUsuarios, estado: TipoFiltroEstado, bloqueado: TipoFiltroBloqueado): any {
        const filtrosRepo: any = {
            limite: filtros.limite,
            offset: filtros.offset,
            username: filtros.username,
            idRol: filtros.idRol
        };

        switch (estado) {
            case TipoFiltroEstado.ACTIVOS:
                filtrosRepo.activo = true;
                break;
            case TipoFiltroEstado.ELIMINADOS:
                filtrosRepo.activo = false;
                break;
            case TipoFiltroEstado.TODOS:
                break;
        }

        switch (bloqueado) {
            case TipoFiltroBloqueado.BLOQUEADOS:
                filtrosRepo.bloqueado = true;
                break;
            case TipoFiltroBloqueado.NO_BLOQUEADOS:
                filtrosRepo.bloqueado = false;
                break;
            case TipoFiltroBloqueado.TODOS:
                break;
        }

        return filtrosRepo;
    }

    private getFiltrosConteo(estado: TipoFiltroEstado, bloqueado: TipoFiltroBloqueado): any {
        const filtros: any = {};

        switch (estado) {
            case TipoFiltroEstado.ACTIVOS:
                filtros.activo = true;
                break;
            case TipoFiltroEstado.ELIMINADOS:
                filtros.activo = false;
                break;
            case TipoFiltroEstado.TODOS:
                break;
        }

        switch (bloqueado) {
            case TipoFiltroBloqueado.BLOQUEADOS:
                filtros.bloqueado = true;
                break;
            case TipoFiltroBloqueado.NO_BLOQUEADOS:
                filtros.bloqueado = false;
                break;
            case TipoFiltroBloqueado.TODOS:
                break;
        }

        return filtros;
    }
}

// ==========================================
// File: src\usuario\aplicacion\casos-uso\obtener-usuario.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { UsuarioRepositorio } from '../../dominio/puertos/repositorios/usuario-repositorio.interface';
import { UsuarioConDetallesDto } from '../dtos/usuario-con-detalles.dto';

export class ObtenerUsuarioCasoUso {
    private readonly logger = new Logger(ObtenerUsuarioCasoUso.name);

    constructor(
        private readonly usuarioRepositorio: UsuarioRepositorio
    ) { }

    async ejecutar(id: number): Promise<UsuarioConDetallesDto> {
        try {
            this.logger.debug(`Buscando usuario con ID ${id}`);

            const usuario = await this.usuarioRepositorio.buscarConDetalles(id);

            if (!usuario) {
                this.logger.warn(`Intento de acceso a usuario inexistente: ID ${id}`);
                throw new Error(`No se encontró un usuario con ID ${id}`);
            }

            this.logger.debug(`Usuario encontrado: ID ${usuario.id}, username: "${usuario.username}", activo: ${usuario.activo}`);

            return new UsuarioConDetallesDto(usuario);

        } catch (error) {
            if (error.message.includes('No se encontró')) {
                this.logger.warn(`Usuario no encontrado: ID ${id}`);
            } else {
                this.logger.error(`Error técnico al buscar usuario ID ${id}: ${error.message}`);
            }
            throw error;
        }
    }
}

// ==========================================
// File: src\usuario\aplicacion\casos-uso\restaurar-usuario.caso-uso.ts
// ==========================================

import { Logger } from '@nestjs/common';
import { UsuarioDominioService } from '../../dominio/servicios/usuario-dominio.service';
import { UsuarioRespuestaDto } from '../dtos/usuario-respuesta.dto';

export class RestaurarUsuarioCasoUso {
    private readonly logger = new Logger(RestaurarUsuarioCasoUso.name);

    constructor(
        private readonly usuarioDominioService: UsuarioDominioService
    ) { }

    async ejecutar(id: number, idUsuarioEjecutor: number): Promise<UsuarioRespuestaDto> {
        try {
            this.logger.log(
                `Iniciando restauración de usuario eliminado: ID ${id}`,
                {
                    operacionRestauracion: {
                        idUsuario: id,
                        idUsuarioEjecutor,
                        timestamp: new Date().toISOString(),
                        razonOperacion: 'RESTAURAR_USUARIO_ELIMINADO'
                    }
                }
            );

            this.logger.debug(
                `Validando condiciones para restauración del usuario ID ${id}`,
                {
                    validaciones: [
                        'existencia_usuario',
                        'estado_eliminado',
                        'conflicto_username',
                        'conflicto_persona'
                    ]
                }
            );

            const usuarioRestaurado = await this.usuarioDominioService.restaurarUsuario(id, idUsuarioEjecutor);

            this.logger.log(
                `Usuario restaurado exitosamente: ID ${id}, username: "${usuarioRestaurado.username}"`,
                {
                    resultadoRestauracion: {
                        idUsuario: usuarioRestaurado.id,
                        usernameUsuario: usuarioRestaurado.username,
                        restauradoPor: idUsuarioEjecutor,
                        estadoFinal: 'ACTIVO',
                        fechaRestauracion: new Date().toISOString()
                    }
                }
            );

            return new UsuarioRespuestaDto(usuarioRestaurado);

        } catch (error) {
            this.logger.error(
                `Error al restaurar usuario ID ${id}: ${error.message}`,
                {
                    contextoErrorRestauracion: {
                        idUsuario: id,
                        idUsuarioEjecutor,
                        tipoError: error.constructor.name,
                        posiblesCausas: [
                            'usuario_no_existe',
                            'usuario_ya_activo',
                            'conflicto_username',
                            'conflicto_persona',
                            'error_validacion'
                        ],
                        momentoError: new Date().toISOString()
                    }
                }
            );
            throw error;
        }
    }
}

// ==========================================
// File: src\usuario\aplicacion\dtos\actualizar-usuario.dto.ts
// ==========================================

import { IsOptional, IsNumber, IsBoolean, IsInt, Min } from 'class-validator';

export class ActualizarUsuarioDto {
    @IsOptional()
    @IsNumber({}, { message: 'El ID del rol debe ser un número' })
    @IsInt({ message: 'El ID del rol debe ser un número entero' })
    @Min(1, { message: 'El ID del rol debe ser mayor a 0' })
    idRol?: number;

    @IsOptional()
    @IsBoolean({ message: 'El estado de bloqueo debe ser verdadero o falso' })
    bloqueado?: boolean;
}

// ==========================================
// File: src\usuario\aplicacion\dtos\cambiar-password.dto.ts
// ==========================================

import { IsNotEmpty, IsString, Length } from 'class-validator';

export class CambiarPasswordDto {
    @IsNotEmpty({ message: 'La nueva contraseña es requerida' })
    @IsString({ message: 'La nueva contraseña debe ser una cadena de texto' })
    @Length(6, 100, { message: 'La nueva contraseña debe tener entre 6 y 100 caracteres' })
    nuevaPassword: string;
}

// ==========================================
// File: src\usuario\aplicacion\dtos\crear-usuario.dto.ts
// ==========================================

import { IsNotEmpty, IsString, IsNumber, IsOptional, Length, Matches, IsInt, Min } from 'class-validator';

export class CrearUsuarioDto {
    @IsNotEmpty({ message: 'El ID de la persona es requerido' })
    @IsNumber({}, { message: 'El ID de la persona debe ser un número' })
    @IsInt({ message: 'El ID de la persona debe ser un número entero' })
    @Min(1, { message: 'El ID de la persona debe ser mayor a 0' })
    idPersona: number;

    @IsNotEmpty({ message: 'El ID del rol es requerido' })
    @IsNumber({}, { message: 'El ID del rol debe ser un número' })
    @IsInt({ message: 'El ID del rol debe ser un número entero' })
    @Min(1, { message: 'El ID del rol debe ser mayor a 0' })
    idRol: number;

    @IsNotEmpty({ message: 'El nombre de usuario es requerido' })
    @IsString({ message: 'El nombre de usuario debe ser una cadena de texto' })
    @Length(3, 50, { message: 'El nombre de usuario debe tener entre 3 y 50 caracteres' })
    @Matches(/^[a-zA-Z0-9._-]+$/, {
        message: 'El nombre de usuario solo puede contener letras, números, puntos, guiones y guiones bajos'
    })
    username: string;

    @IsNotEmpty({ message: 'La contraseña es requerida' })
    @IsString({ message: 'La contraseña debe ser una cadena de texto' })
    @Length(6, 100, { message: 'La contraseña debe tener entre 6 y 100 caracteres' })
    password: string;
}

// ==========================================
// File: src\usuario\aplicacion\dtos\usuario-con-detalles.dto.ts
// ==========================================

export class UsuarioConDetallesDto {
    id: number;
    idPersona: number;
    idRol: number;
    username: string;
    bloqueado: boolean;
    ultimoAcceso: string | null;
    fechaCreacion: string;
    activo: boolean;
    // Datos de la persona
    nombreCompleto: string;
    email: string;
    rut: string;
    // Datos del rol
    nombreRol: string;
    descripcionRol: string | null;

    constructor(usuario: any) {
        this.id = usuario.id;
        this.idPersona = usuario.idPersona;
        this.idRol = usuario.idRol;
        this.username = usuario.username;
        this.bloqueado = usuario.bloqueado;
        this.ultimoAcceso = usuario.ultimoAcceso?.toISOString() || null;
        this.fechaCreacion = usuario.fechaCreacion.toISOString();
        this.activo = usuario.activo;
        this.nombreCompleto = usuario.nombreCompleto;
        this.email = usuario.email;
        this.rut = usuario.rut;
        this.nombreRol = usuario.nombreRol;
        this.descripcionRol = usuario.descripcionRol;
    }
}

// ==========================================
// File: src\usuario\aplicacion\dtos\usuario-respuesta.dto.ts
// ==========================================

export class UsuarioRespuestaDto {
    id: number;
    idPersona: number;
    idRol: number;
    username: string;
    bloqueado: boolean;
    ultimoAcceso: string | null;
    fechaCreacion: string;
    idUsuarioCreacion: number | null;
    fechaModificacion: string | null;
    idUsuarioModificacion: number | null;
    activo: boolean;

    constructor(usuario: any) {
        this.id = usuario.id;
        this.idPersona = usuario.idPersona;
        this.idRol = usuario.idRol;
        this.username = usuario.username;
        this.bloqueado = usuario.bloqueado;
        this.ultimoAcceso = usuario.ultimoAcceso?.toISOString() || null;
        this.fechaCreacion = usuario.fechaCreacion.toISOString();
        this.idUsuarioCreacion = usuario.idUsuarioCreacion;
        this.fechaModificacion = usuario.fechaModificacion?.toISOString() || null;
        this.idUsuarioModificacion = usuario.idUsuarioModificacion;
        this.activo = usuario.activo;
    }
}

// ==========================================
// File: src\usuario\dominio\entidades\usuario.entity.ts
// ==========================================

export class Usuario {
    private _id: number | undefined;
    private _idPersona: number;
    private _idRol: number;
    private _username: string;
    private _password: string;
    private _bloqueado: boolean;
    private _ultimoAcceso: Date | null;
    private _fechaCreacion: Date;
    private _idUsuarioCreacion: number | null;
    private _fechaModificacion: Date | null;
    private _idUsuarioModificacion: number | null;
    private _activo: boolean;

    constructor(params: {
        id?: number;
        idPersona: number;
        idRol: number;
        username: string;
        password: string;
        bloqueado?: boolean;
        ultimoAcceso?: Date | null;
        fechaCreacion?: Date;
        idUsuarioCreacion?: number | null;
        fechaModificacion?: Date | null;
        idUsuarioModificacion?: number | null;
        activo?: boolean;
    }) {
        this.validarIdPersona(params.idPersona);
        this.validarIdRol(params.idRol);
        this.validarUsername(params.username);
        this.validarPassword(params.password);

        this._id = params.id;
        this._idPersona = params.idPersona;
        this._idRol = params.idRol;
        this._username = params.username.trim().toLowerCase();
        this._password = params.password;
        this._bloqueado = params.bloqueado !== undefined ? params.bloqueado : false;
        this._ultimoAcceso = params.ultimoAcceso || null;
        this._fechaCreacion = params.fechaCreacion || new Date();
        this._idUsuarioCreacion = params.idUsuarioCreacion || null;
        this._fechaModificacion = params.fechaModificacion || null;
        this._idUsuarioModificacion = params.idUsuarioModificacion || null;
        this._activo = params.activo !== undefined ? params.activo : true;
    }

    // Getters
    get id(): number {
        if (this._id === undefined) {
            throw new Error('El usuario no ha sido persistido aún');
        }
        return this._id;
    }

    get idPersona(): number { return this._idPersona; }
    get idRol(): number { return this._idRol; }
    get username(): string { return this._username; }
    get password(): string { return this._password; }
    get bloqueado(): boolean { return this._bloqueado; }
    get ultimoAcceso(): Date | null { return this._ultimoAcceso; }
    get fechaCreacion(): Date { return this._fechaCreacion; }
    get idUsuarioCreacion(): number | null { return this._idUsuarioCreacion; }
    get fechaModificacion(): Date | null { return this._fechaModificacion; }
    get idUsuarioModificacion(): number | null { return this._idUsuarioModificacion; }
    get activo(): boolean { return this._activo; }

    // Métodos de negocio
    actualizar(datos: {
        idRol?: number;
        bloqueado?: boolean;
        idUsuarioModificacion: number;
    }): void {
        let huboCambios = false;

        if (datos.idRol && datos.idRol !== this._idRol) {
            this.validarIdRol(datos.idRol);
            this._idRol = datos.idRol;
            huboCambios = true;
        }

        if (datos.bloqueado !== undefined && datos.bloqueado !== this._bloqueado) {
            this._bloqueado = datos.bloqueado;
            huboCambios = true;
        }

        if (huboCambios) {
            this._fechaModificacion = new Date();
            this._idUsuarioModificacion = datos.idUsuarioModificacion;
        }
    }

    cambiarPassword(nuevaPassword: string, idUsuarioModificacion: number): void {
        this.validarPassword(nuevaPassword);
        this._password = nuevaPassword;
        this._fechaModificacion = new Date();
        this._idUsuarioModificacion = idUsuarioModificacion;
    }

    bloquear(idUsuarioModificacion: number): void {
        if (this._bloqueado) {
            throw new Error('El usuario ya está bloqueado');
        }
        this._bloqueado = true;
        this._fechaModificacion = new Date();
        this._idUsuarioModificacion = idUsuarioModificacion;
    }

    desbloquear(idUsuarioModificacion: number): void {
        if (!this._bloqueado) {
            throw new Error('El usuario no está bloqueado');
        }
        this._bloqueado = false;
        this._fechaModificacion = new Date();
        this._idUsuarioModificacion = idUsuarioModificacion;
    }

    registrarAcceso(): void {
        this._ultimoAcceso = new Date();
    }

    desactivar(idUsuarioModificacion: number): void {
        if (!this._activo) {
            throw new Error('El usuario ya está desactivado');
        }
        this._activo = false;
        this._fechaModificacion = new Date();
        this._idUsuarioModificacion = idUsuarioModificacion;
    }

    activar(idUsuarioModificacion: number): void {
        if (this._activo) {
            throw new Error('El usuario ya está activo');
        }
        this._activo = true;
        this._fechaModificacion = new Date();
        this._idUsuarioModificacion = idUsuarioModificacion;
    }

    private validarIdPersona(idPersona: number): void {
        if (!idPersona || idPersona <= 0) {
            throw new Error('El ID de la persona es requerido y debe ser mayor a 0');
        }
    }

    private validarIdRol(idRol: number): void {
        if (!idRol || idRol <= 0) {
            throw new Error('El ID del rol es requerido y debe ser mayor a 0');
        }
    }

    private validarUsername(username: string): void {
        if (!username || username.trim().length === 0) {
            throw new Error('El nombre de usuario es requerido');
        }
        if (username.trim().length < 3) {
            throw new Error('El nombre de usuario debe tener al menos 3 caracteres');
        }
        if (username.trim().length > 50) {
            throw new Error('El nombre de usuario no puede exceder 50 caracteres');
        }
        const caracteresPermitidos = /^[a-zA-Z0-9._-]+$/;
        if (!caracteresPermitidos.test(username.trim())) {
            throw new Error('El nombre de usuario solo puede contener letras, números, puntos, guiones y guiones bajos');
        }
    }

    private validarPassword(password: string): void {
        if (!password || password.length === 0) {
            throw new Error('La contraseña es requerida');
        }
        if (password.length < 6) {
            throw new Error('La contraseña debe tener al menos 6 caracteres');
        }
        if (password.length > 100) {
            throw new Error('La contraseña no puede exceder 100 caracteres');
        }
    }

    puedeIniciarSesion(): boolean {
        return this._activo && !this._bloqueado;
    }

    toString(): string {
        return `Usuario[id=${this._id}, username=${this._username}, activo=${this._activo}, bloqueado=${this._bloqueado}]`;
    }
}

// ==========================================
// File: src\usuario\dominio\excepciones\usuario-domain.exception.ts
// ==========================================

// Clase base para todas las excepciones de dominio relacionadas con usuarios
export abstract class UsuarioDomainException extends Error {
    constructor(message: string) {
        super(message);
        this.name = this.constructor.name;
    }
}

// Excepción para cuando se intenta crear un usuario con un username que ya existe
export class UsuarioUsernameDuplicadoException extends UsuarioDomainException {
    constructor(username: string) {
        super(`Ya existe un usuario con el nombre de usuario "${username}"`);
    }
}

// Excepción para cuando se busca un usuario que no existe
export class UsuarioNoEncontradoException extends UsuarioDomainException {
    constructor(id: number) {
        super(`No se encontró un usuario con ID ${id}`);
    }
}

// Excepción para cuando se intenta operar sobre un usuario inactivo
export class UsuarioInactivoException extends UsuarioDomainException {
    constructor(id: number) {
        super(`El usuario con ID ${id} está inactivo y no puede ser modificado`);
    }
}

// Excepción para cuando se intenta operar sobre un usuario bloqueado
export class UsuarioBloqueadoException extends UsuarioDomainException {
    constructor(username: string) {
        super(`El usuario "${username}" está bloqueado y no puede iniciar sesión`);
    }
}

// Excepción para cuando se intenta eliminar un usuario que tiene dependencias
export class UsuarioConDependenciasException extends UsuarioDomainException {
    constructor(id: number, dependencias: string[]) {
        super(`No se puede eliminar el usuario con ID ${id} porque tiene dependencias en: ${dependencias.join(', ')}`);
    }
}

// Excepción para cuando la persona ya tiene un usuario asignado
export class PersonaYaTieneUsuarioException extends UsuarioDomainException {
    constructor(idPersona: number) {
        super(`La persona con ID ${idPersona} ya tiene un usuario asignado`);
    }
}

// Excepción para cuando se busca una persona que no existe
export class PersonaNoValidaException extends UsuarioDomainException {
    constructor(idPersona: number) {
        super(`La persona con ID ${idPersona} no existe o no está activa`);
    }
}

// Excepción para cuando se busca un rol que no existe
export class RolNoValidoException extends UsuarioDomainException {
    constructor(idRol: number) {
        super(`El rol con ID ${idRol} no existe o no está activo`);
    }
}

// Excepción para validaciones de datos de entrada
export class UsuarioDatosInvalidosException extends UsuarioDomainException {
    constructor(mensaje: string) {
        super(mensaje);
    }
}

// Excepción para credenciales inválidas
export class CredencialesInvalidasException extends UsuarioDomainException {
    constructor() {
        super('Las credenciales proporcionadas son incorrectas');
    }
}

// ==========================================
// File: src\usuario\dominio\puertos\repositorios\usuario-repositorio.interface.ts
// ==========================================

import { Usuario } from '../../entidades/usuario.entity';

// Interfaces para datos enriquecidos
export interface UsuarioConDetalles {
    id: number;
    idPersona: number;
    idRol: number;
    username: string;
    bloqueado: boolean;
    ultimoAcceso: Date | null;
    fechaCreacion: Date;
    activo: boolean;
    // Datos de la persona
    nombreCompleto: string;
    email: string;
    rut: string;
    // Datos del rol
    nombreRol: string;
    descripcionRol: string | null;
}

export interface UsuarioRepositorio {
    // Operaciones básicas CRUD
    guardar(usuario: Usuario): Promise<Usuario>;
    buscarPorId(id: number): Promise<Usuario | null>;
    buscarPorUsername(username: string): Promise<Usuario | null>;
    buscarTodos(filtros?: {
        activo?: boolean;
        bloqueado?: boolean;
        idRol?: number;
        username?: string;
        limite?: number;
        offset?: number;
    }): Promise<Usuario[]>;
    eliminar(id: number, idUsuarioEjecutor: number): Promise<void>;
    restaurar(id: number, idUsuarioEjecutor: number): Promise<void>;

    // Operaciones específicas para usuarios
    buscarConDetalles(id: number): Promise<UsuarioConDetalles | null>;
    listarConDetalles(filtros?: {
        activo?: boolean;
        bloqueado?: boolean;
        idRol?: number;
        username?: string;
        limite?: number;
        offset?: number;
    }): Promise<UsuarioConDetalles[]>;

    // Validaciones específicas
    existeConUsername(username: string, idExcluir?: number): Promise<boolean>;
    existeYEstaActivo(id: number): Promise<boolean>;
    personaYaTieneUsuario(idPersona: number, idExcluir?: number): Promise<boolean>;
    personaExisteYEstaActiva(idPersona: number): Promise<boolean>;
    rolExisteYEstaActivo(idRol: number): Promise<boolean>;
    puedeSerEliminado(id: number): Promise<{
        puedeEliminarse: boolean;
        razon?: string;
        dependencias?: string[];
    }>;
    contarRegistros(filtros?: { activo?: boolean; bloqueado?: boolean }): Promise<number>;

    // Operaciones de autenticación
    actualizarUltimoAcceso(id: number): Promise<void>;
}

// ==========================================
// File: src\usuario\dominio\servicios\usuario-dominio.service.ts
// ==========================================

import { Usuario } from '../entidades/usuario.entity';
import { UsuarioRepositorio } from '../puertos/repositorios/usuario-repositorio.interface';
import {
    UsuarioUsernameDuplicadoException,
    UsuarioNoEncontradoException,
    UsuarioInactivoException,
    UsuarioConDependenciasException,
    PersonaYaTieneUsuarioException,
    PersonaNoValidaException,
    RolNoValidoException,
    UsuarioDatosInvalidosException
} from '../excepciones/usuario-domain.exception';

export interface ResultadoEliminacion {
    id: number;
    username: string;
    nombreCompleto: string;
    fechaEliminacion: Date;
    eliminadoPor: number;
}

export class UsuarioDominioService {
    constructor(private readonly usuarioRepositorio: UsuarioRepositorio) { }

    async validarUsernameUnico(username: string, idExcluir?: number): Promise<void> {
        const existeUsername = await this.usuarioRepositorio.existeConUsername(username, idExcluir);
        if (existeUsername) {
            throw new UsuarioUsernameDuplicadoException(username);
        }
    }

    async validarPersonaUnica(idPersona: number, idExcluir?: number): Promise<void> {
        const personaTieneUsuario = await this.usuarioRepositorio.personaYaTieneUsuario(idPersona, idExcluir);
        if (personaTieneUsuario) {
            throw new PersonaYaTieneUsuarioException(idPersona);
        }
    }

    async validarPersonaExiste(idPersona: number): Promise<void> {
        const personaExiste = await this.usuarioRepositorio.personaExisteYEstaActiva(idPersona);
        if (!personaExiste) {
            throw new PersonaNoValidaException(idPersona);
        }
    }

    async validarRolExiste(idRol: number): Promise<void> {
        const rolExiste = await this.usuarioRepositorio.rolExisteYEstaActivo(idRol);
        if (!rolExiste) {
            throw new RolNoValidoException(idRol);
        }
    }

    async validarExistenciaYEstadoActivo(id: number): Promise<Usuario> {
        const usuario = await this.usuarioRepositorio.buscarPorId(id);
        if (!usuario) {
            throw new UsuarioNoEncontradoException(id);
        }

        if (!usuario.activo) {
            throw new UsuarioInactivoException(id);
        }

        return usuario;
    }

    async validarPuedeSerEliminado(id: number): Promise<void> {
        const resultadoValidacion = await this.usuarioRepositorio.puedeSerEliminado(id);

        if (!resultadoValidacion.puedeEliminarse) {
            throw new UsuarioConDependenciasException(id, resultadoValidacion.dependencias || []);
        }
    }

    async crearUsuario(datos: {
        idPersona: number;
        idRol: number;
        username: string;
        passwordHash: string; // Ya viene hasheada desde el caso de uso
        idUsuarioCreacion: number;
    }): Promise<Usuario> {
        // Validaciones de dominio
        await this.validarPersonaExiste(datos.idPersona);
        await this.validarRolExiste(datos.idRol);
        await this.validarUsernameUnico(datos.username);
        await this.validarPersonaUnica(datos.idPersona);

        const nuevoUsuario = new Usuario({
            idPersona: datos.idPersona,
            idRol: datos.idRol,
            username: datos.username,
            password: datos.passwordHash,
            idUsuarioCreacion: datos.idUsuarioCreacion,
        });

        return await this.usuarioRepositorio.guardar(nuevoUsuario);
    }

    async actualizarUsuario(id: number, datos: {
        idRol?: number;
        bloqueado?: boolean;
        idUsuarioModificacion: number;
    }): Promise<Usuario> {
        const usuario = await this.validarExistenciaYEstadoActivo(id);

        if (datos.idRol && datos.idRol !== usuario.idRol) {
            await this.validarRolExiste(datos.idRol);
        }

        usuario.actualizar(datos);
        return await this.usuarioRepositorio.guardar(usuario);
    }

    async cambiarPassword(id: number, datos: {
        nuevaPasswordHash: string; // Ya viene hasheada desde el caso de uso
        idUsuarioModificacion: number;
    }): Promise<Usuario> {
        const usuario = await this.validarExistenciaYEstadoActivo(id);

        usuario.cambiarPassword(datos.nuevaPasswordHash, datos.idUsuarioModificacion);
        return await this.usuarioRepositorio.guardar(usuario);
    }

    async bloquearUsuario(id: number, idUsuarioEjecutor: number): Promise<Usuario> {
        const usuario = await this.validarExistenciaYEstadoActivo(id);

        usuario.bloquear(idUsuarioEjecutor);
        return await this.usuarioRepositorio.guardar(usuario);
    }

    async desbloquearUsuario(id: number, idUsuarioEjecutor: number): Promise<Usuario> {
        const usuario = await this.validarExistenciaYEstadoActivo(id);

        usuario.desbloquear(idUsuarioEjecutor);
        return await this.usuarioRepositorio.guardar(usuario);
    }

    async eliminarUsuario(id: number, idUsuarioEjecutor: number): Promise<ResultadoEliminacion> {
        // Primero obtenemos los detalles del usuario
        const usuarioDetalles = await this.usuarioRepositorio.buscarConDetalles(id);
        if (!usuarioDetalles) {
            throw new UsuarioNoEncontradoException(id);
        }

        if (!usuarioDetalles.activo) {
            throw new UsuarioInactivoException(id);
        }

        // Validamos que puede ser eliminado
        await this.validarPuedeSerEliminado(id);

        // Ejecutamos la eliminación
        await this.usuarioRepositorio.eliminar(id, idUsuarioEjecutor);

        // Devolvemos información estructurada sobre lo que se eliminó
        return {
            id: usuarioDetalles.id,
            username: usuarioDetalles.username,
            nombreCompleto: usuarioDetalles.nombreCompleto,
            fechaEliminacion: new Date(),
            eliminadoPor: idUsuarioEjecutor
        };
    }

    async restaurarUsuario(id: number, idUsuarioEjecutor: number): Promise<Usuario> {
        const usuario = await this.usuarioRepositorio.buscarPorId(id);
        if (!usuario) {
            throw new UsuarioNoEncontradoException(id);
        }

        if (usuario.activo) {
            throw new UsuarioDatosInvalidosException(`El usuario con ID ${id} ya está activo`);
        }

        // Verificamos que no haya conflicto de username al restaurar
        await this.validarUsernameUnico(usuario.username, id);
        await this.validarPersonaUnica(usuario.idPersona, id);

        await this.usuarioRepositorio.restaurar(id, idUsuarioEjecutor);

        // Retornamos el usuario actualizado
        const usuarioRestaurado = await this.usuarioRepositorio.buscarPorId(id);
        return usuarioRestaurado!;
    }
}

// ==========================================
// File: src\usuario\infraestructura\adaptadores\entrada\controladores\usuario.controller.ts
// ==========================================

import {
    Controller,
    Get,
    Post,
    Put,
    Delete,
    Patch,
    Body,
    Param,
    Query,
    ParseIntPipe,
    HttpStatus,
    HttpCode,
} from '@nestjs/common';
import { CrearUsuarioCasoUso } from '../../../../aplicacion/casos-uso/crear-usuario.caso-uso';
import { ActualizarUsuarioCasoUso } from '../../../../aplicacion/casos-uso/actualizar-usuario.caso-uso';
import { CambiarPasswordCasoUso } from '../../../../aplicacion/casos-uso/cambiar-password.caso-uso';
import { ObtenerUsuarioCasoUso } from '../../../../aplicacion/casos-uso/obtener-usuario.caso-uso';
import { ListarUsuariosCasoUso, FiltrosListarUsuarios, TipoFiltroEstado, TipoFiltroBloqueado } from '../../../../aplicacion/casos-uso/listar-usuarios.caso-uso';
import { EliminarUsuarioCasoUso } from '../../../../aplicacion/casos-uso/eliminar-usuario.caso-uso';
import { RestaurarUsuarioCasoUso } from '../../../../aplicacion/casos-uso/restaurar-usuario.caso-uso';
import { BloquearUsuarioCasoUso } from '../../../../aplicacion/casos-uso/bloquear-usuario.caso-uso';
import { DesbloquearUsuarioCasoUso } from '../../../../aplicacion/casos-uso/desbloquear-usuario.caso-uso';
import { CrearUsuarioDto } from '../../../../aplicacion/dtos/crear-usuario.dto';
import { ActualizarUsuarioDto } from '../../../../aplicacion/dtos/actualizar-usuario.dto';
import { CambiarPasswordDto } from '../../../../aplicacion/dtos/cambiar-password.dto';

@Controller('usuarios')
export class UsuarioController {
    constructor(
        private readonly crearUsuarioCasoUso: CrearUsuarioCasoUso,
        private readonly actualizarUsuarioCasoUso: ActualizarUsuarioCasoUso,
        private readonly cambiarPasswordCasoUso: CambiarPasswordCasoUso,
        private readonly obtenerUsuarioCasoUso: ObtenerUsuarioCasoUso,
        private readonly listarUsuariosCasoUso: ListarUsuariosCasoUso,
        private readonly eliminarUsuarioCasoUso: EliminarUsuarioCasoUso,
        private readonly restaurarUsuarioCasoUso: RestaurarUsuarioCasoUso,
        private readonly bloquearUsuarioCasoUso: BloquearUsuarioCasoUso,
        private readonly desbloquearUsuarioCasoUso: DesbloquearUsuarioCasoUso,
    ) { }

    @Post()
    @HttpCode(HttpStatus.CREATED)
    async crear(@Body() crearUsuarioDto: CrearUsuarioDto) {
        const idUsuarioEjecutor = 1; // TODO: Obtener del contexto de autenticación
        return await this.crearUsuarioCasoUso.ejecutar(crearUsuarioDto, idUsuarioEjecutor);
    }

    /**
     * GET /usuarios
     * Lista usuarios con filtros avanzados y paginación.
     * 
     * Ejemplos de uso:
     * - GET /usuarios (solo usuarios activos, comportamiento por defecto)
     * - GET /usuarios?estado=activos (explícitamente solo activos)
     * - GET /usuarios?estado=eliminados (solo usuarios eliminados/inactivos)
     * - GET /usuarios?estado=todos (todos los usuarios sin importar estado)
     * - GET /usuarios?bloqueado=bloqueados (solo usuarios bloqueados)
     * - GET /usuarios?bloqueado=no_bloqueados (solo usuarios no bloqueados)
     * - GET /usuarios?estado=activos&bloqueado=no_bloqueados&idRol=1 (usuarios activos, no bloqueados, con rol específico)
     * - GET /usuarios?username=admin (buscar "admin" en username)
     * - GET /usuarios?limite=5&offset=10 (paginación)
     */
    @Get()
    async listar(
        @Query('estado') estado?: string,
        @Query('bloqueado') bloqueado?: string,
        @Query('idRol') idRol?: string,
        @Query('username') username?: string,
        @Query('limite') limite?: string,
        @Query('offset') offset?: string,
    ) {
        const filtros: FiltrosListarUsuarios = {};

        // Validar y convertir el parámetro de estado
        if (estado) {
            const estadosValidos = Object.values(TipoFiltroEstado);
            if (estadosValidos.includes(estado as TipoFiltroEstado)) {
                filtros.estado = estado as TipoFiltroEstado;
            } else {
                throw new Error(`Estado '${estado}' no válido. Estados permitidos: ${estadosValidos.join(', ')}`);
            }
        }

        // Validar y convertir el parámetro de bloqueado
        if (bloqueado) {
            const bloqueadosValidos = Object.values(TipoFiltroBloqueado);
            if (bloqueadosValidos.includes(bloqueado as TipoFiltroBloqueado)) {
                filtros.bloqueado = bloqueado as TipoFiltroBloqueado;
            } else {
                throw new Error(`Filtro bloqueado '${bloqueado}' no válido. Valores permitidos: ${bloqueadosValidos.join(', ')}`);
            }
        }

        if (username) {
            filtros.username = username;
        }

        // Validar y convertir idRol
        if (idRol) {
            const idRolNum = parseInt(idRol, 10);
            if (!isNaN(idRolNum) && idRolNum > 0) {
                filtros.idRol = idRolNum;
            } else {
                throw new Error('El ID del rol debe ser un número mayor a 0');
            }
        }

        // Validar y convertir los parámetros numéricos de paginación
        if (limite) {
            const limiteNum = parseInt(limite, 10);
            if (!isNaN(limiteNum) && limiteNum > 0 && limiteNum <= 100) {
                filtros.limite = limiteNum;
            } else {
                throw new Error('El límite debe ser un número entre 1 y 100');
            }
        }

        if (offset) {
            const offsetNum = parseInt(offset, 10);
            if (!isNaN(offsetNum) && offsetNum >= 0) {
                filtros.offset = offsetNum;
            } else {
                throw new Error('El offset debe ser un número mayor o igual a 0');
            }
        }

        return await this.listarUsuariosCasoUso.ejecutar(filtros);
    }

    @Get(':id')
    async obtenerPorId(@Param('id', ParseIntPipe) id: number) {
        return await this.obtenerUsuarioCasoUso.ejecutar(id);
    }

    @Put(':id')
    async actualizar(
        @Param('id', ParseIntPipe) id: number,
        @Body() actualizarUsuarioDto: ActualizarUsuarioDto,
    ) {
        const idUsuarioEjecutor = 1; // TODO: Obtener del contexto de autenticación
        return await this.actualizarUsuarioCasoUso.ejecutar(id, actualizarUsuarioDto, idUsuarioEjecutor);
    }

    /**
     * PATCH /usuarios/:id/password
     * Cambia la contraseña de un usuario específico.
     * 
     * Ejemplo: PATCH /usuarios/5/password
     * Body: { "nuevaPassword": "nuevaContraseña123" }
     */
    @Patch(':id/password')
    async cambiarPassword(
        @Param('id', ParseIntPipe) id: number,
        @Body() cambiarPasswordDto: CambiarPasswordDto,
    ) {
        const idUsuarioEjecutor = 1; // TODO: Obtener del contexto de autenticación
        return await this.cambiarPasswordCasoUso.ejecutar(id, cambiarPasswordDto, idUsuarioEjecutor);
    }

    /**
     * PATCH /usuarios/:id/bloquear
     * Bloquea un usuario específico.
     * 
     * Ejemplo: PATCH /usuarios/5/bloquear
     */
    @Patch(':id/bloquear')
    async bloquear(@Param('id', ParseIntPipe) id: number) {
        const idUsuarioEjecutor = 1; // TODO: Obtener del contexto de autenticación
        return await this.bloquearUsuarioCasoUso.ejecutar(id, idUsuarioEjecutor);
    }

    /**
     * PATCH /usuarios/:id/desbloquear
     * Desbloquea un usuario específico.
     * 
     * Ejemplo: PATCH /usuarios/5/desbloquear
     */
    @Patch(':id/desbloquear')
    async desbloquear(@Param('id', ParseIntPipe) id: number) {
        const idUsuarioEjecutor = 1; // TODO: Obtener del contexto de autenticación
        return await this.desbloquearUsuarioCasoUso.ejecutar(id, idUsuarioEjecutor);
    }

    @Delete(':id')
    async eliminar(@Param('id', ParseIntPipe) id: number) {
        const idUsuarioEjecutor = 1; // TODO: Obtener del contexto de autenticación
        return await this.eliminarUsuarioCasoUso.ejecutar(id, idUsuarioEjecutor);
    }

    /**
     * PATCH /usuarios/:id/restaurar
     * Restaura un usuario eliminado (soft delete) volviéndolo al estado activo.
     * 
     * Ejemplo: PATCH /usuarios/5/restaurar
     */
    @Patch(':id/restaurar')
    async restaurar(@Param('id', ParseIntPipe) id: number) {
        const idUsuarioEjecutor = 1; // TODO: Obtener del contexto de autenticación
        return await this.restaurarUsuarioCasoUso.ejecutar(id, idUsuarioEjecutor);
    }
}

// ==========================================
// File: src\usuario\infraestructura\adaptadores\salida\repositorios\mappers\usuario.mapper.ts
// ==========================================

import { Usuario } from '../../../../../dominio/entidades/usuario.entity';
import { UsuarioOrmEntity } from '../typeorm/entidades/usuario.orm-entity';

export class UsuarioMapper {
    /**
     * Convierte una entidad ORM de TypeORM a una entidad de dominio pura.
     */
    static toDomain(ormEntity: UsuarioOrmEntity): Usuario {
        return new Usuario({
            id: ormEntity.id,
            idPersona: ormEntity.idPersona,
            idRol: ormEntity.idRol,
            username: ormEntity.username,
            password: ormEntity.password,
            bloqueado: ormEntity.bloqueado,
            ultimoAcceso: ormEntity.ultimoAcceso,
            fechaCreacion: ormEntity.fechaCreacion,
            idUsuarioCreacion: ormEntity.idUsuarioCreacion,
            fechaModificacion: ormEntity.fechaModificacion,
            idUsuarioModificacion: ormEntity.idUsuarioModificacion,
            activo: ormEntity.activo,
        });
    }

    /**
     * Convierte una entidad de dominio a una entidad ORM de TypeORM.
     */
    static toOrm(domainEntity: Usuario): UsuarioOrmEntity {
        const ormEntity = new UsuarioOrmEntity();

        // Solo asignamos el ID si la entidad ya fue persistida
        try {
            ormEntity.id = domainEntity.id;
        } catch (error) {
            // Si la entidad no tiene ID, TypeORM hará un INSERT
        }

        ormEntity.idPersona = domainEntity.idPersona;
        ormEntity.idRol = domainEntity.idRol;
        ormEntity.username = domainEntity.username;
        ormEntity.password = domainEntity.password;
        ormEntity.bloqueado = domainEntity.bloqueado;
        ormEntity.ultimoAcceso = domainEntity.ultimoAcceso;
        ormEntity.fechaCreacion = domainEntity.fechaCreacion;
        ormEntity.idUsuarioCreacion = domainEntity.idUsuarioCreacion;
        ormEntity.fechaModificacion = domainEntity.fechaModificacion;
        ormEntity.idUsuarioModificacion = domainEntity.idUsuarioModificacion;
        ormEntity.activo = domainEntity.activo;

        return ormEntity;
    }

    /**
     * Convierte un array de entidades ORM a un array de entidades de dominio.
     */
    static toDomainArray(ormEntities: UsuarioOrmEntity[]): Usuario[] {
        return ormEntities.map(ormEntity => this.toDomain(ormEntity));
    }
}

// ==========================================
// File: src\usuario\infraestructura\adaptadores\salida\repositorios\typeorm\entidades\persona.orm-entity.ts
// ==========================================

import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';

@Entity('persona')
export class PersonaOrmEntity {
    @PrimaryGeneratedColumn({ name: 'id' })
    id: number;

    @Column({ name: 'nombres', type: 'varchar', length: 100, nullable: false })
    nombres: string;

    @Column({ name: 'apellido_paterno', type: 'varchar', length: 50, nullable: false })
    apellidoPaterno: string;

    @Column({ name: 'apellido_materno', type: 'varchar', length: 50, nullable: false })
    apellidoMaterno: string;

    @Column({ name: 'rut', type: 'varchar', length: 12, nullable: false })
    rut: string;

    @Column({ name: 'email', type: 'varchar', length: 255, nullable: false })
    email: string;

    @Column({ name: 'fecha_nacimiento', type: 'date', nullable: true })
    fechaNacimiento: Date | null;

    @Column({ name: 'id_nacionalidad', type: 'int', nullable: true })
    idNacionalidad: number | null;

    @Column({ name: 'id_estado_civil', type: 'int', nullable: true })
    idEstadoCivil: number | null;

    @Column({ name: 'id_genero', type: 'int', nullable: true })
    idGenero: number | null;

    @CreateDateColumn({ name: 'fecha_creacion', type: 'timestamp' })
    fechaCreacion: Date;

    @Column({ name: 'id_usuario_creacion', type: 'int', nullable: true })
    idUsuarioCreacion: number | null;

    @UpdateDateColumn({ name: 'fecha_modificacion', type: 'timestamp', nullable: true })
    fechaModificacion: Date | null;

    @Column({ name: 'id_usuario_modificacion', type: 'int', nullable: true })
    idUsuarioModificacion: number | null;

    @Column({ name: 'activo', type: 'boolean', default: true })
    activo: boolean;
}

// ==========================================
// File: src\usuario\infraestructura\adaptadores\salida\repositorios\typeorm\entidades\usuario.orm-entity.ts
// ==========================================

import { RolOrmEntity } from 'src/rol/infraestructura/adaptadores/salida/repositorios/typeorm/entidades/rol.orm-entity';
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, ManyToOne, JoinColumn } from 'typeorm';

@Entity('usuario')
export class UsuarioOrmEntity {
    @PrimaryGeneratedColumn({ name: 'id' })
    id: number;

    @Column({ name: 'id_persona', type: 'int', nullable: false })
    idPersona: number;

    @Column({ name: 'id_rol', type: 'int', nullable: false })
    idRol: number;

    @Column({ name: 'username', type: 'varchar', length: 50, nullable: false })
    username: string;

    @Column({ name: 'password', type: 'varchar', length: 255, nullable: false })
    password: string;

    @Column({ name: 'bloqueado', type: 'boolean', default: false })
    bloqueado: boolean;

    @Column({ name: 'ultimo_acceso', type: 'timestamp', nullable: true })
    ultimoAcceso: Date | null;

    @CreateDateColumn({ name: 'fecha_creacion', type: 'timestamp' })
    fechaCreacion: Date;

    @Column({ name: 'id_usuario_creacion', type: 'int', nullable: true })
    idUsuarioCreacion: number | null;

    @UpdateDateColumn({ name: 'fecha_modificacion', type: 'timestamp', nullable: true })
    fechaModificacion: Date | null;

    @Column({ name: 'id_usuario_modificacion', type: 'int', nullable: true })
    idUsuarioModificacion: number | null;

    @Column({ name: 'activo', type: 'boolean', default: true })
    activo: boolean;

    // Relación con rol (opcional, útil para consultas)
    @ManyToOne(() => RolOrmEntity)
    @JoinColumn({ name: 'id_rol' })
    rol?: RolOrmEntity;
}

// ==========================================
// File: src\usuario\infraestructura\adaptadores\salida\repositorios\typeorm\usuario.repository.ts
// ==========================================

import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Like, Not, MoreThan } from 'typeorm';
import { UsuarioRepositorio, UsuarioConDetalles } from '../../../../../dominio/puertos/repositorios/usuario-repositorio.interface';
import { Usuario } from '../../../../../dominio/entidades/usuario.entity';
import { UsuarioOrmEntity } from './entidades/usuario.orm-entity';
import { PersonaOrmEntity } from './entidades/persona.orm-entity';
import { RolOrmEntity } from '../../../../../../rol/infraestructura/adaptadores/salida/repositorios/typeorm/entidades/rol.orm-entity';
import { UsuarioMapper } from '../mappers/usuario.mapper';

@Injectable()
export class TypeOrmUsuarioRepository implements UsuarioRepositorio {
    constructor(
        @InjectRepository(UsuarioOrmEntity)
        private readonly usuarioRepository: Repository<UsuarioOrmEntity>,
        @InjectRepository(PersonaOrmEntity)
        private readonly personaRepository: Repository<PersonaOrmEntity>,
        @InjectRepository(RolOrmEntity)
        private readonly rolRepository: Repository<RolOrmEntity>,
    ) { }

    async guardar(usuario: Usuario): Promise<Usuario> {
        try {
            const usuarioOrm = UsuarioMapper.toOrm(usuario);
            const usuarioGuardado = await this.usuarioRepository.save(usuarioOrm);
            return UsuarioMapper.toDomain(usuarioGuardado);
        } catch (error) {
            if (error.code === '23505') {
                if (error.constraint?.includes('username')) {
                    throw new Error(`Ya existe un usuario con el nombre de usuario especificado`);
                }
                throw new Error(`Ya existe un usuario con los datos especificados`);
            }
            throw new Error(`Error al guardar el usuario: ${error.message}`);
        }
    }

    async buscarPorId(id: number): Promise<Usuario | null> {
        const usuarioOrm = await this.usuarioRepository.findOne({
            where: { id }
        });

        return usuarioOrm ? UsuarioMapper.toDomain(usuarioOrm) : null;
    }

    async buscarPorUsername(username: string): Promise<Usuario | null> {
        const usuarioOrm = await this.usuarioRepository.findOne({
            where: { username: username.toLowerCase() }
        });

        return usuarioOrm ? UsuarioMapper.toDomain(usuarioOrm) : null;
    }

    async buscarTodos(filtros: {
        activo?: boolean;
        bloqueado?: boolean;
        idRol?: number;
        username?: string;
        limite?: number;
        offset?: number;
    } = {}): Promise<Usuario[]> {
        const whereConditions: any = {};

        if (filtros.activo !== undefined) {
            whereConditions.activo = filtros.activo;
        }

        if (filtros.bloqueado !== undefined) {
            whereConditions.bloqueado = filtros.bloqueado;
        }

        if (filtros.idRol) {
            whereConditions.idRol = filtros.idRol;
        }

        if (filtros.username) {
            whereConditions.username = Like(`%${filtros.username.toLowerCase()}%`);
        }

        const usuariosOrm = await this.usuarioRepository.find({
            where: whereConditions,
            take: filtros.limite || 10,
            skip: filtros.offset || 0,
            order: {
                username: 'ASC',
            },
        });

        return UsuarioMapper.toDomainArray(usuariosOrm);
    }

    async eliminar(id: number, idUsuarioEjecutor: number): Promise<void> {
        const resultado = await this.usuarioRepository.update(id, {
            activo: false,
            fechaModificacion: new Date(),
            idUsuarioModificacion: idUsuarioEjecutor,
        });

        if (resultado.affected === 0) {
            throw new Error(`No se pudo eliminar el usuario con ID ${id}. Puede que no exista.`);
        }
    }

    async restaurar(id: number, idUsuarioEjecutor: number): Promise<void> {
        const resultado = await this.usuarioRepository.update(id, {
            activo: true,
            fechaModificacion: new Date(),
            idUsuarioModificacion: idUsuarioEjecutor,
        });

        if (resultado.affected === 0) {
            throw new Error(`No se pudo restaurar el usuario con ID ${id}. Puede que no exista.`);
        }
    }

    async buscarConDetalles(id: number): Promise<UsuarioConDetalles | null> {
        const resultado = await this.usuarioRepository
            .createQueryBuilder('usuario')
            .innerJoin('persona', 'persona', 'persona.id = usuario.id_persona')
            .innerJoin('rol', 'rol', 'rol.id = usuario.id_rol')
            .select([
                'usuario.id as id',
                'usuario.id_persona as "idPersona"',
                'usuario.id_rol as "idRol"',
                'usuario.username as username',
                'usuario.bloqueado as bloqueado',
                'usuario.ultimo_acceso as "ultimoAcceso"',
                'usuario.fecha_creacion as "fechaCreacion"',
                'usuario.activo as activo',
                `CONCAT(persona.nombres, ' ', persona.apellido_paterno, ' ', persona.apellido_materno) as "nombreCompleto"`,
                'persona.email as email',
                'persona.rut as rut',
                'rol.nombre as "nombreRol"',
                'rol.descripcion as "descripcionRol"'
            ])
            .where('usuario.id = :id', { id })
            .getRawOne();

        return resultado || null;
    }

    async listarConDetalles(filtros: {
        activo?: boolean;
        bloqueado?: boolean;
        idRol?: number;
        username?: string;
        limite?: number;
        offset?: number;
    } = {}): Promise<UsuarioConDetalles[]> {
        let query = this.usuarioRepository
            .createQueryBuilder('usuario')
            .innerJoin('persona', 'persona', 'persona.id = usuario.id_persona')
            .innerJoin('rol', 'rol', 'rol.id = usuario.id_rol')
            .select([
                'usuario.id as id',
                'usuario.id_persona as "idPersona"',
                'usuario.id_rol as "idRol"',
                'usuario.username as username',
                'usuario.bloqueado as bloqueado',
                'usuario.ultimo_acceso as "ultimoAcceso"',
                'usuario.fecha_creacion as "fechaCreacion"',
                'usuario.activo as activo',
                `CONCAT(persona.nombres, ' ', persona.apellido_paterno, ' ', persona.apellido_materno) as "nombreCompleto"`,
                'persona.email as email',
                'persona.rut as rut',
                'rol.nombre as "nombreRol"',
                'rol.descripcion as "descripcionRol"'
            ]);

        if (filtros.activo !== undefined) {
            query = query.andWhere('usuario.activo = :activo', { activo: filtros.activo });
        }

        if (filtros.bloqueado !== undefined) {
            query = query.andWhere('usuario.bloqueado = :bloqueado', { bloqueado: filtros.bloqueado });
        }

        if (filtros.idRol) {
            query = query.andWhere('usuario.id_rol = :idRol', { idRol: filtros.idRol });
        }

        if (filtros.username) {
            query = query.andWhere('usuario.username ILIKE :username', { username: `%${filtros.username}%` });
        }

        query = query
            .orderBy('usuario.username', 'ASC')
            .limit(filtros.limite || 10)
            .offset(filtros.offset || 0);

        return await query.getRawMany();
    }

    async existeConUsername(username: string, idExcluir?: number): Promise<boolean> {
        const whereConditions: any = {
            username: username.toLowerCase(),
            activo: true,
        };

        if (idExcluir) {
            whereConditions.id = Not(idExcluir);
        }

        const count = await this.usuarioRepository.count({
            where: whereConditions
        });

        return count > 0;
    }

    async existeYEstaActivo(id: number): Promise<boolean> {
        const count = await this.usuarioRepository.count({
            where: {
                id,
                activo: true
            }
        });

        return count > 0;
    }

    async personaYaTieneUsuario(idPersona: number, idExcluir?: number): Promise<boolean> {
        const whereConditions: any = {
            idPersona,
            activo: true,
        };

        if (idExcluir) {
            whereConditions.id = Not(idExcluir);
        }

        const count = await this.usuarioRepository.count({
            where: whereConditions
        });

        return count > 0;
    }

    async personaExisteYEstaActiva(idPersona: number): Promise<boolean> {
        const count = await this.personaRepository.count({
            where: {
                id: idPersona,
                activo: true
            }
        });

        return count > 0;
    }

    async rolExisteYEstaActivo(idRol: number): Promise<boolean> {
        const count = await this.rolRepository.count({
            where: {
                id: idRol,
                activo: true
            }
        });

        return count > 0;
    }

    async puedeSerEliminado(id: number): Promise<{
        puedeEliminarse: boolean;
        razon?: string;
        dependencias?: string[];
    }> {
        const dependencias: string[] = [];

        // Validación 1: Sesiones activas no expiradas
        // Esta validación es crítica porque un usuario con sesiones activas
        // que se "elimina" podría crear inconsistencias en tiempo real
        const sesionesActivas = await this.usuarioRepository.manager.count('sesion', {
            where: {
                idUsuario: id,
                activa: true,
                fechaExpiracion: MoreThan(new Date()) // Solo sesiones no expiradas
            }
        });

        if (sesionesActivas > 0) {
            dependencias.push(`${sesionesActivas} sesión(es) activa(s) que se invalidarían abruptamente`);
        }

        // Validación 2: Protección del último administrador
        // Esta es una validación de seguridad del sistema absolutamente crítica
        const esUltimoAdministrador = await this.esUltimoAdministradorActivo(id);
        if (esUltimoAdministrador) {
            dependencias.push(`Es el único administrador activo - eliminar bloquearía la administración del sistema`);
        }

        if (dependencias.length > 0) {
            return {
                puedeEliminarse: false,
                razon: `No se puede desactivar el usuario por razones de seguridad y continuidad operacional`,
                dependencias
            };
        }

        return { puedeEliminarse: true };
    }

    // Método auxiliar para detectar si es el último administrador activo
    private async esUltimoAdministradorActivo(idUsuario: number): Promise<boolean> {
        // Primero verificamos si este usuario es administrador
        const esAdministrador = await this.usuarioRepository
            .createQueryBuilder('usuario')
            .innerJoin('rol', 'rol', 'rol.id = usuario.id_rol')
            .where('usuario.id = :idUsuario', { idUsuario })
            .andWhere('usuario.activo = true')
            .andWhere('rol.activo = true')
            .andWhere('LOWER(rol.nombre) LIKE :patron', { patron: '%administrador%' })
            .getOne();

        // Si no es administrador, no hay problema
        if (!esAdministrador) {
            return false;
        }

        // Si es administrador, contamos cuántos administradores activos hay en total
        const totalAdministradoresActivos = await this.usuarioRepository
            .createQueryBuilder('usuario')
            .innerJoin('rol', 'rol', 'rol.id = usuario.id_rol')
            .where('usuario.activo = true')
            .andWhere('usuario.bloqueado = false')  // Administradores no bloqueados
            .andWhere('rol.activo = true')
            .andWhere('LOWER(rol.nombre) LIKE :patron', { patron: '%administrador%' })
            .getCount();

        // Es el último si solo hay uno y ese uno es él
        return totalAdministradoresActivos <= 1;
    }

    async contarRegistros(filtros: { activo?: boolean; bloqueado?: boolean } = {}): Promise<number> {
        const whereConditions: any = {};

        if (filtros.activo !== undefined) {
            whereConditions.activo = filtros.activo;
        }

        if (filtros.bloqueado !== undefined) {
            whereConditions.bloqueado = filtros.bloqueado;
        }

        return await this.usuarioRepository.count({
            where: whereConditions
        });
    }

    async actualizarUltimoAcceso(id: number): Promise<void> {
        await this.usuarioRepository.update(id, {
            ultimoAcceso: new Date()
        });
    }
}

// ==========================================
// File: src\usuario\infraestructura\config\usuario.module.ts
// ==========================================

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';

// Importamos las entidades ORM necesarias
import { UsuarioOrmEntity } from '../adaptadores/salida/repositorios/typeorm/entidades/usuario.orm-entity';
import { PersonaOrmEntity } from '../adaptadores/salida/repositorios/typeorm/entidades/persona.orm-entity';
import { RolOrmEntity } from '../../../rol/infraestructura/adaptadores/salida/repositorios/typeorm/entidades/rol.orm-entity';

// Importamos el controlador
import { UsuarioController } from '../adaptadores/entrada/controladores/usuario.controller';

// Importamos la implementación del repositorio
import { TypeOrmUsuarioRepository } from '../adaptadores/salida/repositorios/typeorm/usuario.repository';

// Importamos el servicio de dominio
import { UsuarioDominioService } from '../../dominio/servicios/usuario-dominio.service';

// Importamos todos los casos de uso
import { CrearUsuarioCasoUso } from '../../aplicacion/casos-uso/crear-usuario.caso-uso';
import { ActualizarUsuarioCasoUso } from '../../aplicacion/casos-uso/actualizar-usuario.caso-uso';
import { CambiarPasswordCasoUso } from '../../aplicacion/casos-uso/cambiar-password.caso-uso';
import { ObtenerUsuarioCasoUso } from '../../aplicacion/casos-uso/obtener-usuario.caso-uso';
import { ListarUsuariosCasoUso } from '../../aplicacion/casos-uso/listar-usuarios.caso-uso';
import { EliminarUsuarioCasoUso } from '../../aplicacion/casos-uso/eliminar-usuario.caso-uso';
import { RestaurarUsuarioCasoUso } from '../../aplicacion/casos-uso/restaurar-usuario.caso-uso';
import { BloquearUsuarioCasoUso } from '../../aplicacion/casos-uso/bloquear-usuario.caso-uso';
import { DesbloquearUsuarioCasoUso } from '../../aplicacion/casos-uso/desbloquear-usuario.caso-uso';

@Module({
    // Registramos todas las entidades ORM que necesitamos
    imports: [
        TypeOrmModule.forFeature([
            UsuarioOrmEntity,
            PersonaOrmEntity,
            RolOrmEntity
        ])
    ],

    // Declaramos el controlador
    controllers: [
        UsuarioController
    ],

    // Configuramos la inyección de dependencias
    providers: [
        // Registramos la implementación del repositorio
        {
            provide: 'UsuarioRepositorio',
            useClass: TypeOrmUsuarioRepository,
        },

        // Registramos el servicio de dominio
        {
            provide: UsuarioDominioService,
            useFactory: (usuarioRepositorio) => {
                return new UsuarioDominioService(usuarioRepositorio);
            },
            inject: ['UsuarioRepositorio'],
        },

        // Registramos todos los casos de uso
        {
            provide: CrearUsuarioCasoUso,
            useFactory: (usuarioDominioService) => {
                return new CrearUsuarioCasoUso(usuarioDominioService);
            },
            inject: [UsuarioDominioService],
        },

        {
            provide: ActualizarUsuarioCasoUso,
            useFactory: (usuarioDominioService) => {
                return new ActualizarUsuarioCasoUso(usuarioDominioService);
            },
            inject: [UsuarioDominioService],
        },

        {
            provide: CambiarPasswordCasoUso,
            useFactory: (usuarioDominioService) => {
                return new CambiarPasswordCasoUso(usuarioDominioService);
            },
            inject: [UsuarioDominioService],
        },

        {
            provide: ObtenerUsuarioCasoUso,
            useFactory: (usuarioRepositorio) => {
                return new ObtenerUsuarioCasoUso(usuarioRepositorio);
            },
            inject: ['UsuarioRepositorio'],
        },

        {
            provide: ListarUsuariosCasoUso,
            useFactory: (usuarioRepositorio) => {
                return new ListarUsuariosCasoUso(usuarioRepositorio);
            },
            inject: ['UsuarioRepositorio'],
        },

        {
            provide: EliminarUsuarioCasoUso,
            useFactory: (usuarioDominioService) => {
                return new EliminarUsuarioCasoUso(usuarioDominioService);
            },
            inject: [UsuarioDominioService],
        },

        {
            provide: RestaurarUsuarioCasoUso,
            useFactory: (usuarioDominioService) => {
                return new RestaurarUsuarioCasoUso(usuarioDominioService);
            },
            inject: [UsuarioDominioService],
        },

        {
            provide: BloquearUsuarioCasoUso,
            useFactory: (usuarioDominioService) => {
                return new BloquearUsuarioCasoUso(usuarioDominioService);
            },
            inject: [UsuarioDominioService],
        },

        {
            provide: DesbloquearUsuarioCasoUso,
            useFactory: (usuarioDominioService) => {
                return new DesbloquearUsuarioCasoUso(usuarioDominioService);
            },
            inject: [UsuarioDominioService],
        },
    ],

    // Exportamos servicios que otros módulos podrían necesitar
    exports: [
        'UsuarioRepositorio',
        UsuarioDominioService,
    ],
})
export class UsuarioModule { }
